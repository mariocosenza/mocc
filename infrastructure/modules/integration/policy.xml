<policies>
  <inbound>
      <base />

      <cors allow-credentials="true">
          <allowed-origins>
              <origin>@(context.Request.Headers.GetValueOrDefault("Origin", "*"))</origin>
          </allowed-origins>
          <allowed-methods>
              <method>GET</method>
              <method>POST</method>
              <method>OPTIONS</method>
          </allowed-methods>
          <allowed-headers>
              <header>*</header>
          </allowed-headers>
          <expose-headers>
              <header>*</header>
          </expose-headers>
      </cors>

      <choose>
          <when condition="@(context.Request.Method == &quot;OPTIONS&quot;)">
              <return-response>
                  <set-status code="204" reason="No Content" />
              </return-response>
          </when>
      </choose>

      <validate-jwt header-name="Authorization" failed-validation-httpcode="401" failed-validation-error-message="Unauthorized APIM" require-expiration-time="true" require-scheme="Bearer">
          <openid-config url="https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration" />
          <required-claims>
              <claim name="aud" match="any">
                  <value>__EXPECTED_AUDIENCE__</value>
                  <value>__EXPECTED_AUDIENCE_CLIENT_ID__</value>
              </claim>
              <claim name="scp" match="any" separator=" ">
                  <value>__REQUIRED_SCOPE__</value>
              </claim>
          </required-claims>
      </validate-jwt>

      <set-variable name="extracted-user-id" value="@{
          string auth = context.Request.Headers.GetValueOrDefault(&quot;Authorization&quot;, &quot;&quot;);
          
          if (string.IsNullOrWhiteSpace(auth) || auth.Length &lt; 10) { 
              return &quot;&quot;; 
          }
          
          try {
              var parts = auth.Split(' ');
              var token = parts.Length &gt; 1 ? parts[parts.Length - 1] : parts[0];
              var jwt = token.AsJwt();
              return jwt.Claims.GetValueOrDefault(&quot;oid&quot;, jwt.Subject);
          } catch {
              return &quot;&quot;; 
          }
      }" />

      <set-header name="x-user-id" exists-action="override">
          <value>@((string)context.Variables["extracted-user-id"])</value>
      </set-header>

      <set-variable name="is-signalr-proxy" value="@(context.Request.Url.QueryString.Contains(&quot;signalr=1&quot;))" />

      <set-variable name="request-body" value="@( 
          (bool)context.Variables[&quot;is-signalr-proxy&quot;] 
          ? &quot;&quot; 
          : context.Request.Body.As&lt;string&gt;(preserveContent: true) 
      )" />

      <set-variable name="target-fn" value="@(
          !string.IsNullOrEmpty((string)context.Variables.GetValueOrDefault(&quot;request-body&quot;, &quot;&quot;))
          &amp;&amp; ((string)context.Variables.GetValueOrDefault(&quot;request-body&quot;, &quot;&quot;)).Contains(&quot;registerDevice&quot;)
          ? &quot;true&quot;
          : &quot;false&quot;
      )" />

      <choose>
          <when condition="@((bool)context.Variables[&quot;is-signalr-proxy&quot;])">
              <send-request mode="new" response-variable-name="sig" timeout="30" ignore-error="true">
                  <set-url>{{function-app-url}}/api/negotiate</set-url>
                  <set-method>POST</set-method>
                  
                  <set-header name="x-functions-key" exists-action="override">
                      <value>{{function-key}}</value>
                  </set-header>
                  <set-header name="x-user-id" exists-action="override">
                      <value>@((string)context.Variables[&quot;extracted-user-id&quot;])</value>
                  </set-header>
                  <set-header name="Content-Type" exists-action="override">
                      <value>application/json</value>
                  </set-header>
                  <set-body>{}</set-body>
              </send-request>

              <choose>
                  <when condition="@(context.Variables.GetValueOrDefault(&quot;sig&quot;, null) != null)">
                      <return-response>
                          <set-status code="@(((IResponse)context.Variables[&quot;sig&quot;]).StatusCode)" />
                          <set-header name="Content-Type" exists-action="override">
                              <value>application/json</value>
                          </set-header>
                          <set-body>@(((IResponse)context.Variables[&quot;sig&quot;]).Body.As&lt;string&gt;())</set-body>
                      </return-response>
                  </when>
                  <otherwise>
                      <return-response>
                          <set-status code="502" reason="Bad Gateway" />
                          <set-header name="Content-Type" exists-action="override">
                              <value>application/json</value>
                          </set-header>
                          <set-body>{ "error": "Function App unreachable or timed out." }</set-body>
                      </return-response>
                  </otherwise>
              </choose>
          </when>

          <when condition="@(context.Variables.GetValueOrDefault(&quot;target-fn&quot;, &quot;false&quot;) == &quot;true&quot;)">
              <send-one-way-request mode="new">
                  <set-url>{{function-app-url}}/api/register_device</set-url>
                  <set-method>POST</set-method>
                  <set-header name="x-functions-key" exists-action="override">
                      <value>{{function-key}}</value>
                  </set-header>
                  <set-header name="x-user-id" exists-action="override">
                      <value>@((string)context.Variables[&quot;extracted-user-id&quot;])</value>
                  </set-header>
                  <set-header name="Content-Type" exists-action="override">
                      <value>application/json</value>
                  </set-header>
                  <set-body>@((string)context.Variables[&quot;request-body&quot;])</set-body>
              </send-one-way-request>

              <return-response>
                  <set-status code="200" reason="OK" />
                  <set-header name="Content-Type" exists-action="override">
                      <value>application/json</value>
                  </set-header>
                  <set-body>{ "data": { "registerDevice": true, "__typename": "Mutation" } }</set-body>
              </return-response>
          </when>
      </choose>

      <set-header name="Authorization" exists-action="override">
          <value>@(context.Request.Headers.GetValueOrDefault("Authorization", ""))</value>
      </set-header>
      <set-header name="X-Forwarded-For" exists-action="override">
          <value>@(context.Request.IpAddress)</value>
      </set-header>
      <set-header name="X-Forwarded-Proto" exists-action="override">
          <value>https</value>
      </set-header>
  </inbound>

  <backend>
      <retry condition="@(context.LastError != null || (context.Response != null &amp;&amp; (context.Response.StatusCode == 502 || context.Response.StatusCode == 503 || context.Response.StatusCode == 504)))" count="6" interval="10" first-fast-retry="false">
          <forward-request timeout="120" />
      </retry>
  </backend>

  <outbound>
      <base />
  </outbound>

  <on-error>
      <base />
  </on-error>
</policies>