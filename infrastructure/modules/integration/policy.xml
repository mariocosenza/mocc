<policies>
  <inbound>
    <base />
    <cors allow-credentials="true">
      <allowed-origins>
        <origin>@(context.Request.Headers.GetValueOrDefault("Origin", "*"))</origin>
      </allowed-origins>
      <allowed-methods>
        <method>GET</method>
        <method>POST</method>
        <method>OPTIONS</method>
      </allowed-methods>
      <allowed-headers>
        <header>*</header>
      </allowed-headers>
    </cors>

    <validate-jwt header-name="Authorization"
                  failed-validation-httpcode="401"
                  failed-validation-error-message="Unauthorized APIM"
                  require-expiration-time="true"
                  require-scheme="Bearer">
      <!-- Use 'common' endpoint for multi-tenant support -->
      <openid-config url="https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration" />

      <required-claims>
        <!-- Audience: must match either the App ID URI or the Client ID -->
        <claim name="aud" match="any">
          <value>__EXPECTED_AUDIENCE__</value>
          <value>__EXPECTED_AUDIENCE_CLIENT_ID__</value>
        </claim>

        <!-- 
          Issuer validation removed for multi-tenant support.
          For multi-tenant apps, the issuer contains the user's actual tenant ID,
          not a fixed value. The token signature verification via JWKS is sufficient.
        -->

        <!-- Scope: for delegated permissions, scp is space-separated -->
        <claim name="scp" match="any" separator=" ">
          <value>__REQUIRED_SCOPE__</value>
        </claim>

      </required-claims>
    </validate-jwt>

    <!-- Extract User ID from Token (oid or sub) -->
    <set-header name="x-user-id" exists-action="override">
        <value>@(context.Request.Headers.GetValueOrDefault("Authorization","").AsJwt().Claims.GetValueOrDefault("oid", context.Request.Headers.GetValueOrDefault("Authorization","").AsJwt().Subject))</value>
    </set-header>

    <validate-graphql-request error-variable-name="graphql-validation-error" />
    <choose>
      <when condition='@(!string.IsNullOrEmpty((string)context.Variables.GetValueOrDefault("graphql-validation-error", "")))'>
        <return-response>
          <set-status code="400" reason="Bad Request" />
          <set-header name="Content-Type" exists-action="override">
            <value>application/json</value>
          </set-header>
          <set-body>@{
            var err = (string)context.Variables.GetValueOrDefault("graphql-validation-error", "");
            err = err.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\r", "\\r").Replace("\n", "\\n");
            return "{ \"error\": \"Invalid GraphQL request\", \"details\": \"" + err + "\" }";
          }</set-body>
        </return-response>
      </when>
    </choose>

    <set-variable name="target-fn" value='@{
        var body = context.Request.Body.As&lt;string&gt;(true);
        if (!string.IsNullOrEmpty(body) &amp;&amp; body.Contains("registerDevice")) {
            return "true";
        }
        return "false";
    }' />

    <choose>
        <when condition='@(context.Variables.GetValueOrDefault("target-fn", "") == "true")'>
            <set-backend-service base-url="{{function-app-url}}/api" />
            <rewrite-uri template="/register_device" />
            
            <set-header name="x-functions-key" exists-action="override">
                <value>{{function-key}}</value>
            </set-header>
        </when>
    </choose>

    <!-- Backend URL resolved at runtime via Bicep/APIM definition, no override needed -->
    <!-- <set-backend-service base-url="{{backend-base-url}}/query" /> -->

    <!-- Explicitly forward Authorization header to backend -->
    <set-header name="Authorization" exists-action="override">
      <value>@(context.Request.Headers.GetValueOrDefault("Authorization", ""))</value>
    </set-header>

    <set-header name="X-Forwarded-For" exists-action="override">
      <value>@(context.Request.IpAddress)</value>
    </set-header>
    <set-header name="X-Forwarded-Proto" exists-action="override">
      <value>https</value>
    </set-header>
  </inbound>

  <backend>
    <forward-request timeout="180" />
  </backend>

  <outbound>
    <base />
  </outbound>

  <on-error>
    <base />
  </on-error>
</policies>
