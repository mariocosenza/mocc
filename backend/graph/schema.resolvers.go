package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/data/azcosmos"
	"github.com/google/uuid"
	"github.com/mariocosenza/mocc/graph/model"
)

const errItemNotFound = "item not found"

// UpdateUserPreferences is the resolver for the updateUserPreferences field.
func (r *mutationResolver) UpdateUserPreferences(ctx context.Context, input model.UserPreferencesInput) (*model.User, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.getUser(ctx, uid)
	if err != nil {
		return nil, err
	}

	if input.Currency != nil {
		user.Preferences.Currency = *input.Currency
	}
	if input.DefaultPortions != nil {
		user.Preferences.DefaultPortions = input.DefaultPortions
	}
	if input.DietaryRestrictions != nil {
		user.Preferences.DietaryRestrictions = input.DietaryRestrictions
	}

	if err := r.saveUserToCosmos(ctx, user); err != nil {
		return nil, err
	}
	r.cacheUser(ctx, user)

	return user, nil
}

// UpdateNickname is the resolver for the updateNickname field.
func (r *mutationResolver) UpdateNickname(ctx context.Context, nickname string) (*model.User, error) {
	uuid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}
	r.updateNickname(ctx, uuid, nickname)

	return r.getUser(ctx, uuid)
}

// AddInventoryItem is the resolver for the addInventoryItem field.
func (r *mutationResolver) AddInventoryItem(ctx context.Context, input model.AddInventoryItemInput) (*model.InventoryItem, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	fridge, err := r.getFridge(ctx, uid)
	if err != nil {
		return nil, err
	}

	now := time.Now()
	newItem := &model.InventoryItem{
		ID:               "User@" + uuid.New().String(),
		Name:             input.Name,
		Brand:            input.Brand,
		Category:         input.Category,
		Quantity:         &model.Quantity{Value: input.Quantity.Value, Unit: input.Quantity.Unit},
		VirtualAvailable: input.Quantity.Value,
		Price:            input.Price,
		Status:           model.ItemStatusAvailable,
		ExpiryDate:       input.ExpiryDate, // Assuming DateTime scalar is string compat
		ExpiryType:       input.ExpiryType,
		AddedAt:          now.Format(time.RFC3339),
		ActiveLocks:      []*model.ProductLock{},
	}
	if input.Status != nil {
		newItem.Status = *input.Status
	}

	fridge.Items = append(fridge.Items, newItem)

	if err := r.saveFridge(ctx, fridge); err != nil {
		return nil, err
	}

	return newItem, nil
}

// UpdateInventoryItem is the resolver for the updateInventoryItem field.
func (r *mutationResolver) UpdateInventoryItem(ctx context.Context, id string, input model.UpdateInventoryItemInput) (*model.InventoryItem, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	fridge, err := r.getFridge(ctx, uid)
	if err != nil {
		return nil, err
	}

	var item *model.InventoryItem
	for _, i := range fridge.Items {
		if i.ID == id {
			item = i
			break
		}
	}
	if item == nil {
		return nil, fmt.Errorf(errItemNotFound)
	}

	if input.Name != nil {
		item.Name = *input.Name
	}
	if input.Brand != nil {
		item.Brand = input.Brand
	}
	if input.Category != nil {
		item.Category = input.Category
	}
	if input.Price != nil {
		item.Price = input.Price
	}
	if input.Status != nil {
		item.Status = *input.Status
	}
	if input.Quantity != nil {
		item.Quantity = &model.Quantity{Value: input.Quantity.Value, Unit: input.Quantity.Unit}
		item.VirtualAvailable = input.Quantity.Value // Reset virtual on quantity manual update? Or adjust?
		// Logic: if user updates quantity manually, they probably counted the shelf.
	}
	if input.ExpiryDate != nil {
		item.ExpiryDate = *input.ExpiryDate
	}
	if input.ExpiryType != nil {
		item.ExpiryType = *input.ExpiryType
	}

	if err := r.saveFridge(ctx, fridge); err != nil {
		return nil, err
	}

	return item, nil
}

// DeleteInventoryItem is the resolver for the deleteInventoryItem field.
func (r *mutationResolver) DeleteInventoryItem(ctx context.Context, id string) (bool, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return false, err
	}

	fridge, err := r.getFridge(ctx, uid)
	if err != nil {
		return false, err
	}

	newItems := []*model.InventoryItem{}
	found := false
	for _, i := range fridge.Items {
		if i.ID == id {
			found = true
			continue
		}
		newItems = append(newItems, i)
	}

	if !found {
		return false, nil
	}

	fridge.Items = newItems
	if err := r.saveFridge(ctx, fridge); err != nil {
		return false, err
	}

	return true, nil
}

// ConsumeInventoryItem is the resolver for the consumeInventoryItem field.
func (r *mutationResolver) ConsumeInventoryItem(ctx context.Context, id string, amount float64) (*model.InventoryItem, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	fridge, err := r.getFridge(ctx, uid)
	if err != nil {
		return nil, err
	}

	var item *model.InventoryItem
	for _, i := range fridge.Items {
		if i.ID == id {
			item = i
			break
		}
	}
	if item == nil {
		return nil, fmt.Errorf(errItemNotFound)
	}

	// Reduce quantity
	newVal := item.Quantity.Value - amount
	if newVal < 0 {
		return nil, fmt.Errorf("insufficient quantity")
	}
	item.Quantity.Value = newVal
	item.VirtualAvailable = newVal // Update virtual too

	if newVal == 0 {
		// Set status to CONSUMED? Schema says ItemStatus enum.
		// But in Fridge.items we might want to keep it or move to history?
		// For now just keep it with 0 quantity or let client decide to delete.
		// Or maybe update status if we had that field on item directly (InventoryItem doesn't have status in schema unless added)
		// Schema: type InventoryItem { ... quantity: Quantity! ... }
		// Wait, InventoryItem definition:
		// type InventoryItem { id name brand category quantity virtualAvailable expiryDate expiryType addedAt activeLocks }
		// No status field on InventoryItem. It's implicit by quantity > 0.
	}

	if err := r.saveFridge(ctx, fridge); err != nil {
		return nil, err
	}

	return item, nil
}

// WasteInventoryItem is the resolver for the wasteInventoryItem field.
func (r *mutationResolver) WasteInventoryItem(ctx context.Context, id string, amount float64, reason *string) (*model.InventoryItem, error) {
	return r.ConsumeInventoryItem(ctx, id, amount)
}

// CreateStagingSession is the resolver for the createStagingSession field.
func (r *mutationResolver) CreateStagingSession(ctx context.Context, receiptImageURL *string) (*model.StagingSession, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	sessionID := uuid.New().String()
	now := time.Now()

	session := &model.StagingSession{
		ID:        sessionID,
		Items:     []*model.StagingItem{},
		CreatedAt: now.Format(time.RFC3339),
		ExpiresAt: now.Add(24 * time.Hour).Format(time.RFC3339),
	}
	if receiptImageURL != nil {
		session.Items = append(session.Items, &model.StagingItem{
			ID:            uuid.New().String(),
			Name:          "Detected Apple",
			DetectedPrice: &[]float64{1.50}[0],
			Quantity:      &[]int32{2}[0],
			Confidence:    &[]float64{0.95}[0],
		})
	}

	if err := r.saveStagingSession(ctx, session); err != nil {
		return nil, err
	}
	if err := r.setUserStagingSession(ctx, uid, sessionID); err != nil {
		return nil, err
	}

	return session, nil
}

// AddItemToStaging is the resolver for the addItemToStaging field.
func (r *mutationResolver) AddItemToStaging(ctx context.Context, sessionID string, name string, quantity *int32) (*model.StagingItem, error) {
	// ...
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	currentSessID, err := r.getUserStagingSessionID(ctx, uid)
	if err != nil || currentSessID != sessionID {
		return nil, fmt.Errorf("session not found or access denied")
	}

	session, err := r.getStagingSession(ctx, sessionID)
	if err != nil {
		return nil, err
	}

	item := &model.StagingItem{
		ID:       uuid.New().String(),
		Name:     name,
		Quantity: quantity,
	}
	session.Items = append(session.Items, item)

	if err := r.saveStagingSession(ctx, session); err != nil {
		return nil, err
	}
	return item, nil
}

// UpdateStagingItem is the resolver for the updateStagingItem field.
func (r *mutationResolver) UpdateStagingItem(ctx context.Context, sessionID string, itemID string, input model.StagingItemInput) (*model.StagingItem, error) {
	session, err := r.getStagingSession(ctx, sessionID)
	if err != nil {
		return nil, err
	}

	var item *model.StagingItem
	for _, i := range session.Items {
		if i.ID == itemID {
			item = i
			break
		}
	}
	if item == nil {
		return nil, fmt.Errorf("item not found")
	}

	if input.Name != nil {
		item.Name = *input.Name
	}
	if input.Quantity != nil {
		item.Quantity = input.Quantity
	}
	if input.DetectedPrice != nil {
		item.DetectedPrice = input.DetectedPrice
	}

	if err := r.saveStagingSession(ctx, session); err != nil {
		return nil, err
	}
	return item, nil
}

// DeleteStagingItem is the resolver for the deleteStagingItem field.
func (r *mutationResolver) DeleteStagingItem(ctx context.Context, sessionID string, itemID string) (bool, error) {
	session, err := r.getStagingSession(ctx, sessionID)
	if err != nil {
		return false, err
	}

	newItems := []*model.StagingItem{}
	found := false
	for _, i := range session.Items {
		if i.ID == itemID {
			found = true
			continue
		}
		newItems = append(newItems, i)
	}
	if !found {
		return false, nil
	}

	session.Items = newItems
	if err := r.saveStagingSession(ctx, session); err != nil {
		return false, err
	}
	return true, nil
}

// CommitStagingSession is the resolver for the commitStagingSession field.
func (r *mutationResolver) CommitStagingSession(ctx context.Context, sessionID string) ([]*model.InventoryItem, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	session, err := r.getStagingSession(ctx, sessionID)
	if err != nil {
		return nil, err
	}

	// Add items to Fridge
	fridge, err := r.getFridge(ctx, uid)
	if err != nil {
		return nil, err
	}

	addedItems := []*model.InventoryItem{}
	now := time.Now()

	for _, sItem := range session.Items {
		qty := int32(1)
		if sItem.Quantity != nil {
			qty = *sItem.Quantity
		}

		newItem := &model.InventoryItem{
			ID:               uuid.New().String(),
			Name:             sItem.Name,
			Quantity:         &model.Quantity{Value: float64(qty), Unit: model.UnitPz}, // Default unit
			VirtualAvailable: float64(qty),
			Price:            sItem.DetectedPrice,
			Status:           model.ItemStatusAvailable,
			ExpiryDate:       now.Add(7 * 24 * time.Hour).Format(time.RFC3339), // Default expiry 1 week
			ExpiryType:       model.ExpiryTypeBestBefore,
			AddedAt:          now.Format(time.RFC3339),
			ActiveLocks:      []*model.ProductLock{},
		}
		fridge.Items = append(fridge.Items, newItem)
		addedItems = append(addedItems, newItem)
	}

	if err := r.saveFridge(ctx, fridge); err != nil {
		return nil, err
	}

	// Cleanup session
	r.clearUserStagingSession(ctx, uid)
	r.Redis.Del(ctx, "staging:session:"+sessionID)

	return addedItems, nil
}

// DiscardStagingSession is the resolver for the discardStagingSession field.
func (r *mutationResolver) DiscardStagingSession(ctx context.Context, sessionID string) (bool, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return false, err
	}
	r.clearUserStagingSession(ctx, uid)
	r.Redis.Del(ctx, "staging:session:"+sessionID)
	return true, nil
}

// CreateRecipe is the resolver for the createRecipe field.
func (r *mutationResolver) CreateRecipe(ctx context.Context, input model.CreateRecipeInput) (*model.Recipe, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	ingredients := []*model.RecipeIngredient{}
	for _, i := range input.Ingredients {
		ingredients = append(ingredients, &model.RecipeIngredient{
			Name:                i.Name,
			Quantity:            i.Quantity,
			Unit:                i.Unit,
			IsAvailableInFridge: false, // Calculated on read usually
		})
	}

	steps := []string{}
	if input.Steps != nil {
		steps = input.Steps
	}

	desc := ""
	if input.Description != nil {
		desc = *input.Description
	}

	newRecipe := &model.Recipe{
		ID:              uuid.New().String(),
		AuthorID:        uid,
		Title:           input.Title,
		Description:     desc,
		Status:          model.RecipeStatusProposed,
		Ingredients:     ingredients,
		Steps:           steps,
		PrepTimeMinutes: input.PrepTimeMinutes,
		Calories:        input.Calories,
		EcoPointsReward: input.EcoPointsReward,
		GeneratedByAi:   false,
	}

	if err := r.saveRecipe(ctx, newRecipe); err != nil {
		return nil, err
	}

	return newRecipe, nil
}

// UpdateRecipe is the resolver for the updateRecipe field.
func (r *mutationResolver) UpdateRecipe(ctx context.Context, id string, input model.UpdateRecipeInput) (*model.Recipe, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	recipe, err := r.getRecipe(ctx, id)
	if err != nil {
		return nil, err
	}

	if recipe.AuthorID != uid {
		return nil, fmt.Errorf("unauthorized")
	}

	if input.Title != nil {
		recipe.Title = *input.Title
	}
	if input.Description != nil {
		recipe.Description = *input.Description
	}
	if input.Status != nil {
		recipe.Status = *input.Status
	}
	if input.Ingredients != nil {
		ingredients := []*model.RecipeIngredient{}
		for _, i := range input.Ingredients {
			ingredients = append(ingredients, &model.RecipeIngredient{
				Name:     i.Name,
				Quantity: i.Quantity,
				Unit:     i.Unit,
			})
		}
		recipe.Ingredients = ingredients
	}
	if input.Steps != nil {
		recipe.Steps = input.Steps
	}
	if input.PrepTimeMinutes != nil {
		recipe.PrepTimeMinutes = input.PrepTimeMinutes
	}
	if input.Calories != nil {
		recipe.Calories = input.Calories
	}

	if err := r.saveRecipe(ctx, recipe); err != nil {
		return nil, err
	}

	return recipe, nil
}

// DeleteRecipe is the resolver for the deleteRecipe field.
func (r *mutationResolver) DeleteRecipe(ctx context.Context, id string) (bool, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return false, err
	}

	// Just check if it exists and author matches
	recipe, err := r.getRecipe(ctx, id)
	if err != nil {
		return false, err
	}

	if recipe.AuthorID != uid {
		return false, fmt.Errorf("unauthorized")
	}

	container, err := r.Cosmos.NewContainer(cosmosDatabase, containerCookbook)
	if err != nil {
		return false, err
	}

	// Delete needs PK which is AuthorID
	_, err = container.DeleteItem(ctx, azcosmos.NewPartitionKeyString(recipe.AuthorID), id, nil)
	if err != nil {
		return false, err
	}
	return true, nil
}

// SaveRecipe is the resolver for the saveRecipe field.
func (r *mutationResolver) SaveRecipe(ctx context.Context, id string) (*model.Recipe, error) {
	panic(fmt.Errorf("not implemented: SaveRecipe - saveRecipe"))
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.CreatePostInput) (*model.Post, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	// Verify recipe exists
	_, err = r.getRecipe(ctx, input.RecipeID)
	if err != nil {
		return nil, fmt.Errorf("recipe not found")
	}

	postID := uuid.New().String()
	now := time.Now().Format(time.RFC3339)

	// We use a map to include "type" for Partition Key
	postData := map[string]interface{}{}
	postData["id"] = postID
	postData["type"] = "post" // Critical for Social container PK
	postData["authorId"] = uid
	postData["recipeId"] = input.RecipeID
	if input.Caption != nil {
		postData["caption"] = *input.Caption
	}
	if input.ImageURL != nil {
		postData["imageUrl"] = *input.ImageURL
	}
	postData["likes"] = 0
	postData["createdAt"] = now
	postData["comments"] = []interface{}{}

	container, err := r.Cosmos.NewContainer(cosmosDatabase, containerSocial)
	if err != nil {
		return nil, err
	}

	data, err := json.Marshal(postData)
	if err != nil {
		return nil, err
	}

	// PK is /type -> "post"
	_, err = container.UpsertItem(ctx, azcosmos.NewPartitionKeyString("post"), data, nil)
	if err != nil {
		return nil, err
	}

	// Award points
	r.updateLeaderboard(ctx, uid, 10)

	// Fetch author and recipe for return model
	author, _ := r.getUser(ctx, uid)
	recipe, _ := r.getRecipe(ctx, input.RecipeID)

	imgURL := ""
	if input.ImageURL != nil {
		imgURL = *input.ImageURL
	}

	// Return model
	return &model.Post{
		ID:             postID,
		Author:         author,
		RecipeSnapshot: recipe,
		Caption:        input.Caption,
		ImageURL:       imgURL,
		LikesCount:     0,
		IsLikedByMe:    false,
		CreatedAt:      now,
		Comments:       []*model.Comment{},
	}, nil
}

// DeletePost is the resolver for the deletePost field.
func (r *mutationResolver) DeletePost(ctx context.Context, id string) (bool, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return false, err
	}

	container, err := r.Cosmos.NewContainer(cosmosDatabase, containerSocial)
	if err != nil {
		return false, err
	}

	// Read first to check author
	// PK is "post"
	itemResponse, err := container.ReadItem(ctx, azcosmos.NewPartitionKeyString("post"), id, nil)
	if err != nil {
		return false, err
	}

	var postData map[string]interface{}
	if err := json.Unmarshal(itemResponse.Value, &postData); err != nil {
		return false, err
	}

	// helper to safely get string
	getStr := func(m map[string]interface{}, k string) string {
		if v, ok := m[k]; ok {
			if s, ok := v.(string); ok {
				return s
			}
		}
		return ""
	}

	if getStr(postData, "authorId") != uid {
		return false, fmt.Errorf("unauthorized")
	}

	_, err = container.DeleteItem(ctx, azcosmos.NewPartitionKeyString("post"), id, nil)
	return err == nil, err
}

// LikePost is the resolver for the likePost field.
func (r *mutationResolver) LikePost(ctx context.Context, id string) (*model.Post, error) {
	_, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	container, err := r.Cosmos.NewContainer(cosmosDatabase, containerSocial)
	if err != nil {
		return nil, err
	}

	// PK is "post"
	patchOps := azcosmos.PatchOperations{}
	patchOps.AppendIncrement("/likes", 1)

	resp, err := container.PatchItem(ctx, azcosmos.NewPartitionKeyString("post"), id, patchOps, nil)
	if err != nil {
		return nil, err
	}

	var post model.Post
	if err := json.Unmarshal(resp.Value, &post); err != nil {
		return nil, err
	}
	return &post, nil
}

// UnlikePost is the resolver for the unlikePost field.
func (r *mutationResolver) UnlikePost(ctx context.Context, id string) (*model.Post, error) {
	_, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	container, err := r.Cosmos.NewContainer(cosmosDatabase, containerSocial)
	if err != nil {
		return nil, err
	}

	// PK is "post"
	patchOps := azcosmos.PatchOperations{}
	patchOps.AppendIncrement("/likes", -1)

	resp, err := container.PatchItem(ctx, azcosmos.NewPartitionKeyString("post"), id, patchOps, nil)
	if err != nil {
		return nil, err
	}

	var post model.Post
	if err := json.Unmarshal(resp.Value, &post); err != nil {
		return nil, err
	}
	return &post, nil
}

// GenerateUploadSasToken is the resolver for the generateUploadSasToken field.
func (r *mutationResolver) GenerateUploadSasToken(ctx context.Context, filename string) (string, error) {
	// TODO: Implement actual SAS token generation using azblob
	// For now, return a placeholder or error
	// return "", fmt.Errorf("SAS token generation not configured yet")

	// Example of what it should look like:
	// sasQueryParams, err := sas.BlobSignatureValues{ ... }.Sign(credential)
	// return fmt.Sprintf("https://%s.blob.core.windows.net/%s/%s?%s", accountName, container, filename, sasQueryParams.Encode()), nil

	return "https://mockstorage.blob.core.windows.net/staging/" + filename + "?sv=2023-01-03&st=2023...", nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	return r.getUser(ctx, uid)
}

// MyFridge is the resolver for the myFridge field.
func (r *queryResolver) MyFridge(ctx context.Context) (*model.Fridge, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}
	return r.getFridge(ctx, uid)
}

// CurrentStagingSession is the resolver for the currentStagingSession field.
func (r *queryResolver) CurrentStagingSession(ctx context.Context) (*model.StagingSession, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	sessionID, err := r.getUserStagingSessionID(ctx, uid)
	if err != nil {
		return nil, nil // No active session
	}

	return r.getStagingSession(ctx, sessionID)
}

// ShoppingHistory is the resolver for the shoppingHistory field.
func (r *queryResolver) ShoppingHistory(ctx context.Context, limit *int32, offset *int32) ([]*model.ShoppingHistoryEntry, error) {
	// Not implemented yet
	return []*model.ShoppingHistoryEntry{}, nil
}

// MyRecipes is the resolver for the myRecipes field.
func (r *queryResolver) MyRecipes(ctx context.Context, status *model.RecipeStatus) ([]*model.Recipe, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	query := "SELECT * FROM c WHERE c.authorId = @uid"
	if status != nil {
		query += fmt.Sprintf(" AND c.status = '%s'", *status)
	}

	container, err := r.Cosmos.NewContainer(cosmosDatabase, containerCookbook)
	if err != nil {
		return nil, err
	}

	qOpts := azcosmos.QueryOptions{
		QueryParameters: []azcosmos.QueryParameter{
			{Name: "@uid", Value: uid},
		},
	}

	// Use PK = AuthorID = uid
	pager := container.NewQueryItemsPager(query, azcosmos.NewPartitionKeyString(uid), &qOpts)

	var recipes []*model.Recipe
	for pager.More() {
		resp, err := pager.NextPage(ctx)
		if err != nil {
			return nil, err
		}
		for _, bytes := range resp.Items {
			var recipe model.Recipe
			if err := json.Unmarshal(bytes, &recipe); err == nil {
				recipes = append(recipes, &recipe)
			}
		}
	}
	return recipes, nil
}

// Recipe is the resolver for the recipe field.
func (r *queryResolver) Recipe(ctx context.Context, id string) (*model.Recipe, error) {
	return r.getRecipe(ctx, id)
}

// Feed is the resolver for the feed field.
func (r *queryResolver) Feed(ctx context.Context, limit *int32, offset *int32) ([]*model.Post, error) {
	// Cross-partition query on PK /type = 'post'
	container, err := r.Cosmos.NewContainer(cosmosDatabase, containerSocial)
	if err != nil {
		return nil, err
	}

	query := "SELECT * FROM c WHERE c.type = 'post' ORDER BY c.createdAt DESC"

	qOpts := azcosmos.QueryOptions{}

	// Use PK = 'post'
	pager := container.NewQueryItemsPager(query, azcosmos.NewPartitionKeyString("post"), &qOpts)

	var posts []*model.Post
	for pager.More() {
		resp, err := pager.NextPage(ctx)
		if err != nil {
			return nil, err
		}
		for _, bytes := range resp.Items {
			var post model.Post
			if err := json.Unmarshal(bytes, &post); err == nil {
				posts = append(posts, &post)
			}
		}
		if limit != nil && len(posts) >= int(100) { // Safety break
			break
		}
	}

	start := 0
	if offset != nil {
		start = int(*offset)
	}
	end := len(posts)
	if limit != nil {
		l := int(*limit)
		if start+l < end {
			end = start + l
		}
	} else {
		if start+20 < end {
			end = start + 20
		}
	}

	if start > len(posts) {
		return []*model.Post{}, nil
	}
	if end > len(posts) {
		end = len(posts)
	}
	if start > end {
		return []*model.Post{}, nil
	}

	return posts[start:end], nil
}

// Leaderboard is the resolver for the leaderboard field.
func (r *queryResolver) Leaderboard(ctx context.Context, top *int32) ([]*model.LeaderboardEntry, error) {
	limit := 5
	if top != nil {
		limit = int(*top)
	}
	return r.getLeaderboard(ctx, limit)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
