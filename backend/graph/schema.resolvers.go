package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/data/azcosmos"
	"github.com/Azure/azure-sdk-for-go/sdk/storage/azblob/sas"
	"github.com/google/uuid"
	"github.com/mariocosenza/mocc/graph/model"
	"github.com/mariocosenza/mocc/internal/logic"
)

// UpdateUserPreferences is the resolver for the updateUserPreferences field.
func (r *mutationResolver) UpdateUserPreferences(ctx context.Context, input model.UserPreferencesInput) (*model.User, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.FetchUser(ctx, uid)
	if err != nil {
		return nil, err
	}

	if input.Currency != nil {
		user.Preferences.Currency = *input.Currency
	}
	if input.DefaultPortions != nil {
		user.Preferences.DefaultPortions = input.DefaultPortions
	}
	if input.DietaryRestrictions != nil {
		user.Preferences.DietaryRestrictions = input.DietaryRestrictions
	}

	if err := r.UpsertUser(ctx, user); err != nil {
		return nil, err
	}
	r.SetUserCache(ctx, user)

	return user, nil
}

// UpdateNickname is the resolver for the updateNickname field.
func (r *mutationResolver) UpdateNickname(ctx context.Context, nickname string) (*model.User, error) {
	if nickname == "" {
		return nil, fmt.Errorf("nickname cannot be empty")
	}

	// Validate allowed characters (letters, numbers, underscores)
	validNickname := regexp.MustCompile(`^[a-zA-Z0-9_]+$`)
	if !validNickname.MatchString(nickname) {
		return nil, fmt.Errorf("nickname can only contain letters, numbers, and underscores")
	}

	uuid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}
	r.SyncNickname(ctx, uuid, nickname)

	// Propagate nickname to Social Posts
	// 1. Update posts where user is author
	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerSocial)
	if err == nil {
		pk := azcosmos.NewPartitionKeyString("post")
		uidParam := azcosmos.QueryParameter{Name: "@uid", Value: uuid}
		queryOpts := &azcosmos.QueryOptions{
			QueryParameters: []azcosmos.QueryParameter{uidParam},
		}

		// Query 1: Author
		pager := container.NewQueryItemsPager("SELECT * FROM c WHERE c.authorId = @uid", pk, queryOpts)
		for pager.More() {
			resp, err := pager.NextPage(ctx)
			if err != nil {
				fmt.Printf("Error paging posts: %v\n", err)
				break
			}
			for _, bytes := range resp.Items {
				var post model.Post
				if err := json.Unmarshal(bytes, &post); err == nil {
					if post.AuthorNickname != nickname {
						post.AuthorNickname = nickname
						// Also check comments while we are here to save a write
						for _, c := range post.Comments {
							if c.UserID == uuid {
								c.UserNickname = nickname
							}
						}

						updatedBytes, _ := json.Marshal(post)
						// Helper map to preserve "type": "post"
						var postMap map[string]interface{}
						json.Unmarshal(updatedBytes, &postMap)
						postMap["type"] = "post"
						finalBytes, _ := json.Marshal(postMap)

						if _, err := container.UpsertItem(ctx, pk, finalBytes, nil); err != nil {
							fmt.Printf("Error updating post %s: %v\n", post.ID, err)
						} else {
							fmt.Printf("Successfully updated nickname in post %s\n", post.ID)
						}
					}
				}
			}
		}

		// Query 2: Commenter (and not Author, to avoid double write, though double write is safe but wasteful)
		// SELECT * FROM c WHERE ARRAY_CONTAINS(c.comments, {'userId': @uid}, true) AND c.authorId != @uid
		pagerComments := container.NewQueryItemsPager("SELECT * FROM c WHERE ARRAY_CONTAINS(c.comments, {'userId': @uid}, true) AND c.authorId != @uid", pk, queryOpts)
		for pagerComments.More() {
			resp, err := pagerComments.NextPage(ctx)
			if err != nil {
				break
			}
			for _, bytes := range resp.Items {
				var post model.Post
				if err := json.Unmarshal(bytes, &post); err == nil {
					updated := false
					for _, c := range post.Comments {
						if c.UserID == uuid && c.UserNickname != nickname {
							c.UserNickname = nickname
							updated = true
						}
					}

					if updated {
						updatedBytes, _ := json.Marshal(post)
						var postMap map[string]interface{}
						json.Unmarshal(updatedBytes, &postMap)
						postMap["type"] = "post"
						finalBytes, _ := json.Marshal(postMap)
						if _, err := container.UpsertItem(ctx, pk, finalBytes, nil); err != nil {
							fmt.Printf("Error updating post comment %s: %v\n", post.ID, err)
						} else {
							fmt.Printf("Successfully updated nickname in post comment %s\n", post.ID)
						}
					}
				}
			}
		}
	} else {
		fmt.Printf("Error getting social container: %v\n", err)
	}

	return r.FetchUser(ctx, uuid)
}

// AddInventoryItem is the resolver for the addInventoryItem field.
func (r *mutationResolver) AddInventoryItem(ctx context.Context, input model.AddInventoryItemInput) (*model.InventoryItem, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	fridge, err := r.FetchFridge(ctx, uid)
	if err != nil {
		return nil, err
	}

	now := time.Now()
	newItem := &model.InventoryItem{
		ID:               "User@" + uuid.New().String(),
		Name:             input.Name,
		Brand:            input.Brand,
		Category:         input.Category,
		Quantity:         &model.Quantity{Value: input.Quantity.Value, Unit: input.Quantity.Unit},
		VirtualAvailable: input.Quantity.Value,
		Price:            input.Price,
		Status:           model.ItemStatusAvailable,
		ExpiryDate:       input.ExpiryDate, // Assuming DateTime scalar is string compat
		ExpiryType:       input.ExpiryType,
		AddedAt:          now.Format(time.RFC3339),
		ActiveLocks:      []*model.ProductLock{},
	}
	if input.Status != nil {
		newItem.Status = *input.Status
	}

	fridge.Items = append(fridge.Items, newItem)

	if err := r.UpsertFridge(ctx, fridge); err != nil {
		return nil, err
	}

	return newItem, nil
}

// UpdateInventoryItem is the resolver for the updateInventoryItem field.
func (r *mutationResolver) UpdateInventoryItem(ctx context.Context, id string, input model.UpdateInventoryItemInput) (*model.InventoryItem, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	fridge, err := r.FetchFridge(ctx, uid)
	if err != nil {
		return nil, err
	}

	var item *model.InventoryItem
	for _, i := range fridge.Items {
		if i.ID == id {
			item = i
			break
		}
	}
	if item == nil {
		return nil, fmt.Errorf(logic.ErrItemNotFound)
	}

	if input.Name != nil {
		item.Name = *input.Name
	}
	if input.Brand != nil {
		item.Brand = input.Brand
	}
	if input.Category != nil {
		item.Category = input.Category
	}
	if input.Price != nil {
		item.Price = input.Price
	}
	if input.Status != nil {
		item.Status = *input.Status
	}
	if input.Quantity != nil {
		item.Quantity = &model.Quantity{Value: input.Quantity.Value, Unit: input.Quantity.Unit}

		// Recalculate virtual available based on new quantity
		item.VirtualAvailable = item.Quantity.Value
		var activeLocksTotal float64 = 0
		for _, l := range item.ActiveLocks {
			activeLocksTotal += l.Amount
		}
		item.VirtualAvailable -= activeLocksTotal

		// Validation: check if new quantity is less than locked amount
		if item.VirtualAvailable < -0.001 {
			return nil, fmt.Errorf("cannot reduce quantity below locked amount (%f)", activeLocksTotal)
		}
	}
	if input.ExpiryDate != nil {
		item.ExpiryDate = *input.ExpiryDate
	}
	if input.ExpiryType != nil {
		item.ExpiryType = *input.ExpiryType
	}

	if err := r.UpsertFridge(ctx, fridge); err != nil {
		return nil, err
	}

	return item, nil
}

// DeleteInventoryItem is the resolver for the deleteInventoryItem field.
func (r *mutationResolver) DeleteInventoryItem(ctx context.Context, id string) (bool, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return false, err
	}

	fridge, err := r.FetchFridge(ctx, uid)
	if err != nil {
		return false, err
	}

	newItems := []*model.InventoryItem{}
	found := false
	for _, i := range fridge.Items {
		if i.ID == id {
			if len(i.ActiveLocks) > 0 {
				return false, fmt.Errorf("cannot delete item %s because it is used in active recipes", i.Name)
			}
			found = true
			continue
		}
		newItems = append(newItems, i)
	}

	if !found {
		return false, nil
	}

	fridge.Items = newItems
	if err := r.UpsertFridge(ctx, fridge); err != nil {
		return false, err
	}

	return true, nil
}

// ConsumeInventoryItem is the resolver for the consumeInventoryItem field.
func (r *mutationResolver) ConsumeInventoryItem(ctx context.Context, id string, amount float64) (*model.InventoryItem, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	fridge, err := r.FetchFridge(ctx, uid)
	if err != nil {
		return nil, err
	}

	var item *model.InventoryItem
	var itemIndex int
	for i, it := range fridge.Items {
		if it.ID == id {
			item = it
			itemIndex = i
			break
		}
	}
	if item == nil {
		return nil, fmt.Errorf(logic.ErrItemNotFound)
	}

	newVal := item.Quantity.Value - amount
	if newVal < 0 {
		return nil, fmt.Errorf("insufficient quantity")
	}
	item.Quantity.Value = newVal
	item.VirtualAvailable = newVal

	if newVal == 0 {
		if len(item.ActiveLocks) > 0 {
			return nil, fmt.Errorf("cannot consume item %s completely because it is used in active recipes", item.Name)
		}
		fridge.Items = append(fridge.Items[:itemIndex], fridge.Items[itemIndex+1:]...)
	}

	if err := r.UpsertFridge(ctx, fridge); err != nil {
		return nil, err
	}

	return item, nil
}

// WasteInventoryItem is the resolver for the wasteInventoryItem field.
func (r *mutationResolver) WasteInventoryItem(ctx context.Context, id string, amount float64, reason *string) (*model.InventoryItem, error) {
	return r.ConsumeInventoryItem(ctx, id, amount)
}

// CreateStagingSession is the resolver for the createStagingSession field.
func (r *mutationResolver) CreateStagingSession(ctx context.Context, receiptImageURL *string) (*model.StagingSession, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	sessionID := uuid.New().String()
	now := time.Now()

	session := &model.StagingSession{
		ID:        sessionID,
		AuthorID:  uid,
		Items:     []*model.StagingItem{},
		CreatedAt: now.Format(time.RFC3339),
	}
	if receiptImageURL != nil {
		session.Items = append(session.Items, &model.StagingItem{
			ID:            uuid.New().String(),
			Name:          "Detected Apple",
			DetectedPrice: &[]float64{1.50}[0],
			Quantity:      &[]int32{2}[0],
			Confidence:    &[]float64{0.95}[0],
		})
	}

	if err := r.UpsertStagingSession(ctx, session); err != nil {
		return nil, err
	}

	return session, nil
}

// AddItemToStaging is the resolver for the addItemToStaging field.
func (r *mutationResolver) AddItemToStaging(ctx context.Context, sessionID string, name string, quantity *int32) (*model.StagingItem, error) {
	// ...
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	currentSessID, err := r.FetchUserStagingID(ctx, uid)
	if err != nil || currentSessID != sessionID {
		return nil, fmt.Errorf("session not found or access denied")
	}

	session, err := r.FetchStagingSession(ctx, sessionID, uid)
	if err != nil {
		return nil, err
	}

	item := &model.StagingItem{
		ID:       uuid.New().String(),
		Name:     name,
		Quantity: quantity,
	}
	session.Items = append(session.Items, item)

	if err := r.UpsertStagingSession(ctx, session); err != nil {
		return nil, err
	}
	return item, nil
}

// UpdateStagingItem is the resolver for the updateStagingItem field.
func (r *mutationResolver) UpdateStagingItem(ctx context.Context, sessionID string, itemID string, input model.StagingItemInput) (*model.StagingItem, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	session, err := r.FetchStagingSession(ctx, sessionID, uid)
	if err != nil {
		return nil, err
	}

	var item *model.StagingItem
	for _, i := range session.Items {
		if i.ID == itemID {
			item = i
			break
		}
	}
	if item == nil {
		return nil, fmt.Errorf("item not found")
	}

	if input.Name != nil {
		item.Name = *input.Name
	}
	if input.Quantity != nil {
		item.Quantity = input.Quantity
	}
	if input.DetectedPrice != nil {
		item.DetectedPrice = input.DetectedPrice
	}

	if err := r.UpsertStagingSession(ctx, session); err != nil {
		return nil, err
	}
	return item, nil
}

// DeleteStagingItem is the resolver for the deleteStagingItem field.
func (r *mutationResolver) DeleteStagingItem(ctx context.Context, sessionID string, itemID string) (bool, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return false, err
	}

	session, err := r.FetchStagingSession(ctx, sessionID, uid)
	if err != nil {
		return false, err
	}

	newItems := []*model.StagingItem{}
	found := false
	for _, i := range session.Items {
		if i.ID == itemID {
			found = true
			continue
		}
		newItems = append(newItems, i)
	}
	if !found {
		return false, nil
	}

	session.Items = newItems
	if err := r.UpsertStagingSession(ctx, session); err != nil {
		return false, err
	}
	return true, nil
}

// CommitStagingSession is the resolver for the commitStagingSession field.
func (r *mutationResolver) CommitStagingSession(ctx context.Context, sessionID string) ([]*model.InventoryItem, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	session, err := r.FetchStagingSession(ctx, sessionID, uid)
	if err != nil {
		return nil, err
	}

	// Add items to Fridge
	fridge, err := r.FetchFridge(ctx, uid)
	if err != nil {
		return nil, err
	}

	addedItems := []*model.InventoryItem{}
	now := time.Now()

	for _, sItem := range session.Items {
		qty := int32(1)
		if sItem.Quantity != nil {
			qty = *sItem.Quantity
		}

		newItem := &model.InventoryItem{
			ID:               uuid.New().String(),
			Name:             sItem.Name,
			Quantity:         &model.Quantity{Value: float64(qty), Unit: model.UnitPz}, // Default unit
			VirtualAvailable: float64(qty),
			Price:            sItem.DetectedPrice,
			Status:           model.ItemStatusAvailable,
			ExpiryDate:       now.Add(7 * 24 * time.Hour).Format(time.RFC3339), // Default expiry 1 week
			ExpiryType:       model.ExpiryTypeBestBefore,
			AddedAt:          now.Format(time.RFC3339),
			ActiveLocks:      []*model.ProductLock{},
		}
		fridge.Items = append(fridge.Items, newItem)
		addedItems = append(addedItems, newItem)
	}

	if err := r.UpsertFridge(ctx, fridge); err != nil {
		return nil, err
	}

	// Cleanup session
	r.PurgeUserStaging(ctx, uid)
	r.Redis.Del(ctx, "staging:session:"+sessionID)

	return addedItems, nil
}

// DiscardStagingSession is the resolver for the discardStagingSession field.
func (r *mutationResolver) DiscardStagingSession(ctx context.Context, sessionID string) (bool, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return false, err
	}
	r.PurgeUserStaging(ctx, uid)
	r.Redis.Del(ctx, "staging:session:"+sessionID)
	return true, nil
}

// CreateRecipe is the resolver for the createRecipe field.
func (r *mutationResolver) CreateRecipe(ctx context.Context, input model.CreateRecipeInput) (*model.Recipe, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	ingredients := []*model.RecipeIngredient{}
	for _, i := range input.Ingredients {
		ingredients = append(ingredients, &model.RecipeIngredient{
			Name:                i.Name,
			Quantity:            i.Quantity,
			Unit:                i.Unit,
			InventoryItemID:     i.InventoryItemID,
			IsAvailableInFridge: false, // Calculated on read usually
		})
	}

	steps := []string{}
	if input.Steps != nil {
		steps = input.Steps
	}

	desc := ""
	if input.Description != nil {
		desc = *input.Description
	}

	newRecipe := &model.Recipe{
		ID:              uuid.New().String(),
		AuthorID:        uid,
		Title:           input.Title,
		Description:     desc,
		Status:          model.RecipeStatusProposed,
		Ingredients:     ingredients,
		Steps:           steps,
		PrepTimeMinutes: input.PrepTimeMinutes,
		Calories:        input.Calories,
		EcoPointsReward: input.EcoPointsReward,
		GeneratedByAi:   false,
	}

	newRecipe.Status = model.RecipeStatusProposed

	if err := r.UpsertRecipe(ctx, newRecipe); err != nil {
		return nil, err
	}

	return newRecipe, nil
}

// UpdateRecipe is the resolver for the updateRecipe field.
func (r *mutationResolver) UpdateRecipe(ctx context.Context, id string, input model.UpdateRecipeInput) (*model.Recipe, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	recipe, err := r.FetchRecipe(ctx, id)
	if err != nil {
		return nil, err
	}

	if recipe.AuthorID != uid {
		return nil, fmt.Errorf("unauthorized")
	}

	if recipe.Status == model.RecipeStatusCooked {
		return nil, fmt.Errorf("cannot modify a cooked recipe")
	}

	if recipe.GeneratedByAi {
		return nil, fmt.Errorf("cannot modify AI generated recipe")
	}

	if input.Title != nil {
		recipe.Title = *input.Title
	}
	if input.Description != nil {
		recipe.Description = *input.Description
	}
	ingredientsChanged := false
	if input.Ingredients != nil {
		ingredients := []*model.RecipeIngredient{}
		for _, i := range input.Ingredients {
			ingredients = append(ingredients, &model.RecipeIngredient{
				Name:            i.Name,
				Quantity:        i.Quantity,
				Unit:            i.Unit,
				InventoryItemID: i.InventoryItemID,
			})
		}
		recipe.Ingredients = ingredients
		ingredientsChanged = true
	}
	if input.Steps != nil {
		recipe.Steps = input.Steps
	}
	if input.PrepTimeMinutes != nil {
		recipe.PrepTimeMinutes = input.PrepTimeMinutes
	}
	if input.Calories != nil {
		recipe.Calories = input.Calories
	}

	// Status Transition Logic
	if input.Status != nil {
		oldStatus := recipe.Status
		newStatus := *input.Status

		if newStatus != oldStatus {
			// 1. Proposed -> InPreparation (Lock)
			if oldStatus == model.RecipeStatusProposed && newStatus == model.RecipeStatusInPreparation {
				if err := r.LockIngredients(ctx, uid, recipe); err != nil {
					return nil, err
				}
			}

			// 2. InPreparation -> Proposed OR Saved (Unlock)
			if oldStatus == model.RecipeStatusInPreparation && (newStatus == model.RecipeStatusProposed || newStatus == model.RecipeStatusSaved) {
				if err := r.UnlockIngredients(ctx, uid, recipe.ID); err != nil {
					return nil, err
				}
			}

			// 3. Any -> Cooked (Handle Consumption)
			// If it was InPreparation, we need to unlock first to release reservations
			if oldStatus == model.RecipeStatusInPreparation && newStatus == model.RecipeStatusCooked {
				if err := r.UnlockIngredients(ctx, uid, recipe.ID); err != nil {
					return nil, err
				}
			}
			// Now consume the actual quantity (for cooked)
			if newStatus == model.RecipeStatusCooked {
				if err := r.ApplyCooking(ctx, uid, recipe); err != nil {
					return nil, err
				}

				// Gamification logic...
				points := int32(0)
				if recipe.EcoPointsReward != nil {
					points = *recipe.EcoPointsReward
				}

				if points > 0 {
					user, err := r.FetchUser(ctx, uid)
					if err != nil {
						return nil, err
					}

					if user.Gamification == nil {
						user.Gamification = &model.GamificationProfile{
							CurrentLevel:       1,
							NextLevelThreshold: 100,
						}
					}

					user.Gamification.TotalEcoPoints += points
					r.EvaluateLevelUp(user)

					if err := r.UpsertUser(ctx, user); err != nil {
						return nil, err
					}

					r.UpsertLeaderboardEntry(ctx, user)
					r.SetUserCache(ctx, user)
				}
			}
		}
		recipe.Status = *input.Status
	} else if ingredientsChanged && recipe.Status == model.RecipeStatusInPreparation {
		// If status didn't change but ingredients did, and we are InPreparation, re-lock
		if err := r.UnlockIngredients(ctx, uid, recipe.ID); err != nil {
			return nil, err
		}
		if err := r.LockIngredients(ctx, uid, recipe); err != nil {
			return nil, err
		}
	}

	if err := r.UpsertRecipe(ctx, recipe); err != nil {
		return nil, err
	}

	return recipe, nil
}

// DeleteRecipe is the resolver for the deleteRecipe field.
func (r *mutationResolver) DeleteRecipe(ctx context.Context, id string) (bool, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return false, err
	}

	// Just check if it exists and author matches
	recipe, err := r.FetchRecipe(ctx, id)
	if err != nil {
		return false, err
	}

	if recipe.AuthorID != uid {
		return false, fmt.Errorf("unauthorized")
	}

	// Only unlock if the recipe was NOT cooked.
	// If it is cooked, the ingredients are consumed and should not be restored.
	if recipe.Status != model.RecipeStatusCooked {
		if err := r.UnlockIngredients(ctx, uid, recipe.ID); err != nil {
			return false, err
		}
	}

	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerCookbook)
	if err != nil {
		return false, err
	}

	// Delete needs PK which is AuthorID
	_, err = container.DeleteItem(ctx, azcosmos.NewPartitionKeyString(recipe.AuthorID), id, nil)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CookRecipe is the resolver for the cookRecipe field.
func (r *mutationResolver) CookRecipe(ctx context.Context, id string) (*model.Recipe, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	recipe, err := r.FetchRecipe(ctx, id)
	if err != nil {
		return nil, err
	}

	if recipe.AuthorID != uid {
		return nil, fmt.Errorf("unauthorized")
	}

	if recipe.Status == model.RecipeStatusCooked {
		return recipe, nil
	}

	// Always unlock first to release any existing reservations (if it was InPreparation)
	if err := r.UnlockIngredients(ctx, uid, recipe.ID); err != nil {
		return nil, err
	}

	if err := r.ApplyCooking(ctx, uid, recipe); err != nil {
		return nil, err
	}

	recipe.Status = model.RecipeStatusCooked
	if err := r.UpsertRecipe(ctx, recipe); err != nil {
		return nil, err
	}

	return recipe, nil
}

// SaveRecipe is the resolver for the saveRecipe field.
func (r *mutationResolver) SaveRecipe(ctx context.Context, id string) (*model.Recipe, error) {
	panic(fmt.Errorf("not implemented: SaveRecipe - saveRecipe"))
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.CreatePostInput) (*model.Post, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	// Verify recipe exists
	recipe, err := r.FetchRecipe(ctx, input.RecipeID)
	if err != nil {
		return nil, fmt.Errorf("recipe not found")
	}

	// Get Author details
	author, err := r.FetchUser(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("user not found")
	}

	// Create Snapshot
	ings := []*model.RecipeIngredientSnapshot{}
	for _, i := range recipe.Ingredients {
		ings = append(ings, &model.RecipeIngredientSnapshot{
			Name:     i.Name,
			Quantity: i.Quantity,
			Unit:     i.Unit,
		})
	}

	desc := recipe.Description
	snapshot := &model.RecipeSnapshot{
		Title:           recipe.Title,
		Description:     &desc,
		Ingredients:     ings,
		Steps:           recipe.Steps,
		PrepTimeMinutes: recipe.PrepTimeMinutes,
		Calories:        recipe.Calories,
		EcoPointsReward: recipe.EcoPointsReward,
	}

	postID := uuid.New().String()
	now := time.Now().Format(time.RFC3339)

	imgURL := ""
	if input.ImageURL != nil && *input.ImageURL != "" {
		// Expecting clean URL (no SAS). We need to extract the blob name.
		// URL format: https://<account>.blob.core.windows.net/social/pending/<uuid>.jpg
		u, err := url.Parse(*input.ImageURL)
		if err != nil {
			return nil, fmt.Errorf("invalid image url")
		}

		// Path should contain "social/pending/"
		if !strings.Contains(u.Path, "/social/pending/") {
			return nil, fmt.Errorf("image must be uploaded via the app")
		}

		// Extract blob name: "pending/<uuid>.jpg"
		parts := strings.Split(u.Path, "/social/")
		if len(parts) < 2 {
			return nil, fmt.Errorf("invalid blob path")
		}
		srcBlobName := parts[1] // "pending/..."

		destBlobName := "posts/" + postID + ".jpg"
		// Extract extension from srcBlobName if possible
		if dot := strings.LastIndex(srcBlobName, "."); dot != -1 {
			destBlobName = "posts/" + postID + srcBlobName[dot:]
		}

		// Move Blob
		finalURL, err := r.RelocateBlob(ctx, "social", srcBlobName, destBlobName)
		if err != nil {
			return nil, fmt.Errorf("failed to process image: %v", err)
		}
		imgURL = finalURL
	}

	newPost := &model.Post{
		ID:             postID,
		AuthorID:       uid,
		AuthorNickname: author.Nickname,
		RecipeSnapshot: snapshot,
		Caption:        input.Caption,
		ImageURL:       &imgURL,
		LikesCount:     0,
		LikedBy:        []string{},
		CreatedAt:      now,
		Comments:       []*model.Comment{},
	}

	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerSocial)
	if err != nil {
		return nil, err
	}

	// Use map to include "type" field for partition key logic

	postMap := map[string]interface{}{}
	b, _ := json.Marshal(newPost)
	json.Unmarshal(b, &postMap)
	postMap["type"] = "post"

	data, err := json.Marshal(postMap)
	if err != nil {
		return nil, err
	}

	_, err = container.UpsertItem(ctx, azcosmos.NewPartitionKeyString("post"), data, nil)
	if err != nil {
		return nil, err
	}

	// Award points
	if author.Gamification == nil {
		// Load user again? We have author.
		author.Gamification = &model.GamificationProfile{TotalEcoPoints: 0, CurrentLevel: 1, NextLevelThreshold: 100}
	}
	author.Gamification.TotalEcoPoints += 10
	if err := r.UpsertUser(ctx, author); err == nil {
		r.UpsertLeaderboardEntry(ctx, author)
		r.SetUserCache(ctx, author)
	}

	return newPost, nil
}

// UpdatePost is the resolver for the updatePost field.
func (r *mutationResolver) UpdatePost(ctx context.Context, id string, caption string) (*model.Post, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerSocial)
	if err != nil {
		return nil, err
	}

	// Read Post
	var post model.Post
	resp, err := container.ReadItem(ctx, azcosmos.NewPartitionKeyString("post"), id, nil)
	if err != nil {
		return nil, err
	}
	if err := json.Unmarshal(resp.Value, &post); err != nil {
		return nil, err
	}

	// Check Authorization
	if post.AuthorID != uid {
		return nil, fmt.Errorf("unauthorized")
	}

	// Update logic
	post.Caption = &caption

	// Save back (preserving "type"="post")
	postMap := map[string]interface{}{}
	b, _ := json.Marshal(post)
	json.Unmarshal(b, &postMap)
	postMap["type"] = "post"

	finalData, _ := json.Marshal(postMap)
	_, err = container.UpsertItem(ctx, azcosmos.NewPartitionKeyString("post"), finalData, nil)
	if err != nil {
		return nil, err
	}

	return &post, nil
}

// DeletePost is the resolver for the deletePost field.
func (r *mutationResolver) DeletePost(ctx context.Context, id string) (bool, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return false, err
	}

	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerSocial)
	if err != nil {
		return false, err
	}

	// PK is "post"
	itemResponse, err := container.ReadItem(ctx, azcosmos.NewPartitionKeyString("post"), id, nil)
	if err != nil {
		return false, err
	}

	var postData map[string]interface{}
	if err := json.Unmarshal(itemResponse.Value, &postData); err != nil {
		return false, err
	}

	authorId, ok := postData["authorId"].(string)
	if !ok || authorId != uid {
		return false, fmt.Errorf("unauthorized")
	}

	_, err = container.DeleteItem(ctx, azcosmos.NewPartitionKeyString("post"), id, nil)
	return err == nil, err
}

// LikePost is the resolver for the likePost field.
func (r *mutationResolver) LikePost(ctx context.Context, postID string) (*model.Post, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerSocial)
	if err != nil {
		return nil, err
	}

	// Read Post
	var post model.Post // Note: this won't have "type", but that's fine for unmarshal
	resp, err := container.ReadItem(ctx, azcosmos.NewPartitionKeyString("post"), postID, nil)
	if err != nil {
		return nil, err
	}
	if err := json.Unmarshal(resp.Value, &post); err != nil {
		return nil, err
	}

	// Check if already liked
	alreadyLiked := false
	for _, id := range post.LikedBy {
		if id == uid {
			alreadyLiked = true
			break
		}
	}

	if !alreadyLiked {
		post.LikedBy = append(post.LikedBy, uid)
		post.LikesCount = int32(len(post.LikedBy))

		// Save back (preserving "type"="post")
		postMap := map[string]interface{}{}
		b, _ := json.Marshal(post)
		json.Unmarshal(b, &postMap)
		postMap["type"] = "post"

		finalData, _ := json.Marshal(postMap)
		_, err = container.UpsertItem(ctx, azcosmos.NewPartitionKeyString("post"), finalData, nil)
		if err != nil {
			return nil, err
		}
	}

	return &post, nil
}

// UnlikePost is the resolver for the unlikePost field.
func (r *mutationResolver) UnlikePost(ctx context.Context, postID string) (*model.Post, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerSocial)
	if err != nil {
		return nil, err
	}

	var post model.Post
	resp, err := container.ReadItem(ctx, azcosmos.NewPartitionKeyString("post"), postID, nil)
	if err != nil {
		return nil, err
	}
	if err := json.Unmarshal(resp.Value, &post); err != nil {
		return nil, err
	}

	newLikedBy := []string{}
	found := false
	for _, id := range post.LikedBy {
		if id == uid {
			found = true
			continue
		}
		newLikedBy = append(newLikedBy, id)
	}

	if found {
		post.LikedBy = newLikedBy
		post.LikesCount = int32(len(post.LikedBy))

		postMap := map[string]interface{}{}
		b, _ := json.Marshal(post)
		json.Unmarshal(b, &postMap)
		postMap["type"] = "post"

		finalData, _ := json.Marshal(postMap)
		_, err = container.UpsertItem(ctx, azcosmos.NewPartitionKeyString("post"), finalData, nil)
		if err != nil {
			return nil, err
		}
	}

	return &post, nil
}

// AddComment is the resolver for the addComment field.
func (r *mutationResolver) AddComment(ctx context.Context, postID string, text string) (*model.Comment, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.FetchUser(ctx, uid)
	if err != nil {
		return nil, err
	}

	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerSocial)
	if err != nil {
		return nil, err
	}

	var post model.Post
	resp, err := container.ReadItem(ctx, azcosmos.NewPartitionKeyString("post"), postID, nil)
	if err != nil {
		return nil, err
	}
	if err := json.Unmarshal(resp.Value, &post); err != nil {
		return nil, err
	}

	newComment := &model.Comment{
		ID:           uuid.New().String(),
		UserID:       uid,
		UserNickname: user.Nickname,
		Text:         text,
		CreatedAt:    time.Now().Format(time.RFC3339),
	}

	post.Comments = append(post.Comments, newComment)

	// Sort comments by date (newest first or oldest? User said "sort the comment by date")
	// Usually social comments are oldest first (thread) or newest first.
	// "post details... should be visible only when tapping... sort the comment by date"
	// I'll keep them appended, and maybe sort on display or insertion.
	// Appending puts it at end (latest). Default order usually fine.

	postMap := map[string]interface{}{}
	b, _ := json.Marshal(post)
	json.Unmarshal(b, &postMap)
	postMap["type"] = "post"

	finalData, _ := json.Marshal(postMap)
	_, err = container.UpsertItem(ctx, azcosmos.NewPartitionKeyString("post"), finalData, nil)
	if err != nil {
		return nil, err
	}

	return newComment, nil
}

// GenerateUploadSasToken is the resolver for the generateUploadSasToken field.
// GenerateUploadSasToken is the resolver for the generateUploadSasToken field.
func (r *mutationResolver) GenerateUploadSasToken(ctx context.Context, filename string, purpose model.UploadPurpose) (string, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return "", err
	}

	containerName := "uploads"
	prefix := ""

	switch purpose {
	case model.UploadPurposeSocialPost:
		prefix = fmt.Sprintf("social/users/%s", uid)
	case model.UploadPurposeRecipeGeneration:
		prefix = fmt.Sprintf("recipes-input/users/%s", uid)
		containerName = "recipes-input"
	case model.UploadPurposeReceiptScanning:
		// User requested to reuse 'uploads' container
		// Path: receipts/{userId}/{filename}
		containerName = "uploads"
		prefix = fmt.Sprintf("receipts/%s", uid)
	default:
		return "", fmt.Errorf("invalid upload purpose")
	}

	// Validate filename (basic)
	if filename == "" {
		return "", fmt.Errorf("filename required")
	}

	// Ensure container exists (fixes 404 local issue)
	if err := r.CreateContainerIfNotExists(ctx, containerName); err != nil {
		fmt.Printf("Warning: Failed to ensure container exists: %v\n", err)
	}

	blobName := fmt.Sprintf("%s/%s", prefix, filename)

	// Use Logic helper which handles Dev/Prod (DefaultCredential) automatically
	perms := sas.BlobPermissions{Read: true, Create: true, Write: true}

	sasUrl, err := r.CreateSAS(ctx, containerName, blobName, perms, 1*time.Hour)
	if err == nil {
		fmt.Printf("Generated SAS URL: %s\n", sasUrl)
	}
	return sasUrl, err
}

// RegisterDevice is the resolver for the registerDevice field.
// RegisterDevice is the resolver for the registerDevice field.
func (r *mutationResolver) RegisterDevice(ctx context.Context, handle string, platform string, installationID *string) (bool, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return false, err
	}

	// Forward to Azure Function (Local Dev or deployed URL)
	funcURL := os.Getenv("AZURE_FUNCTIONS_URL")
	if funcURL == "" {
		funcURL = "http://localhost:7071/api"
	}
	registerURL := fmt.Sprintf("%s/register_device", funcURL)

	payload := map[string]interface{}{
		"handle":         handle,
		"platform":       platform,
		"userId":         uid, // Function needs explicit userId
		"installationId": installationID,
	}

	jsonBody, _ := json.Marshal(payload)
	req, err := http.NewRequest("POST", registerURL, bytes.NewBuffer(jsonBody))
	if err != nil {
		// Should rarely happen unless marshalling fails
		fmt.Printf("Failed to create request to Function: %v\n", err)
		return true, nil // Mock success if we can't even create request
	}
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{Timeout: 5 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		// Graceful Fallback: If Function App is not running locally, just log and return success.
		// Use os.Stderr or fmt to log warning visible in console.
		fmt.Printf("WARNING: Notification registration failed (Function App unreachable at %s). Ignoring for local dev.\n", funcURL)
		return true, nil
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 && resp.StatusCode != 201 {
		bodyBytes, _ := io.ReadAll(resp.Body)
		fmt.Printf("WARNING: Notification registration returned error: %s\n", string(bodyBytes))
		// Optional: fail if strictly needed, but per user request "avoid registering... if running locally" implies we shouldn't block.
		return true, nil
	}

	return true, nil
}

// AddShoppingHistory is the resolver for the addShoppingHistory field.
func (r *mutationResolver) AddShoppingHistory(ctx context.Context, input model.AddShoppingHistoryInput) (*model.ShoppingHistoryEntry, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.FetchUser(ctx, uid)
	if err != nil {
		return nil, err
	}

	currency := "EUR"
	if input.Currency != nil {
		currency = *input.Currency
	} else if user.Preferences != nil {
		currency = user.Preferences.Currency.String()
	}

	items := []*model.HistoryItem{}
	for _, i := range input.Items {
		items = append(items, &model.HistoryItem{
			Name:       i.Name,
			Price:      i.Price,
			Quantity:   i.Quantity,
			Category:   i.Category,
			Brand:      i.Brand,
			Unit:       i.Unit,
			ExpiryDate: i.ExpiryDate,
			ExpiryType: i.ExpiryType,
		})
	}

	entry := &model.ShoppingHistoryEntry{
		ID:            uuid.New().String(),
		AuthorID:      uid,
		Date:          input.Date,
		StoreName:     input.StoreName,
		TotalAmount:   input.TotalAmount,
		Currency:      currency,
		IsImported:    false,
		ItemsSnapshot: items,
	}

	if err := r.UpsertShoppingHistory(ctx, entry); err != nil {
		return nil, err
	}

	return entry, nil
}

// UpdateShoppingHistory is the resolver for the updateShoppingHistory field.
func (r *mutationResolver) UpdateShoppingHistory(ctx context.Context, id string, input model.UpdateShoppingHistoryInput) (*model.ShoppingHistoryEntry, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	entry, err := r.FetchShoppingHistory(ctx, id)
	if err != nil {
		return nil, err
	}

	if entry.AuthorID != uid {
		return nil, fmt.Errorf("unauthorized")
	}

	if entry.IsImported {
		return nil, fmt.Errorf("cannot update imported history")
	}

	if input.StoreName != nil {
		entry.StoreName = *input.StoreName
	}
	if input.TotalAmount != nil {
		entry.TotalAmount = *input.TotalAmount
	}
	if input.Date != nil {
		entry.Date = *input.Date
	}
	if input.Currency != nil {
		entry.Currency = *input.Currency
	}
	if input.Items != nil {
		items := []*model.HistoryItem{}
		for _, i := range input.Items {
			items = append(items, &model.HistoryItem{
				Name:       i.Name,
				Price:      i.Price,
				Quantity:   i.Quantity,
				Category:   i.Category,
				Brand:      i.Brand,
				Unit:       i.Unit,
				ExpiryDate: i.ExpiryDate,
				ExpiryType: i.ExpiryType,
			})
		}
		entry.ItemsSnapshot = items
	}

	if err := r.UpsertShoppingHistory(ctx, entry); err != nil {
		return nil, err
	}

	return entry, nil
}

// DeleteShoppingHistory is the resolver for the deleteShoppingHistory field.
func (r *mutationResolver) DeleteShoppingHistory(ctx context.Context, id string) (bool, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return false, err
	}

	entry, err := r.FetchShoppingHistory(ctx, id)
	if err != nil {
		return false, err
	}

	if entry.AuthorID != uid {
		return false, fmt.Errorf("unauthorized")
	}

	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerHistory)
	if err != nil {
		return false, err
	}

	_, err = container.DeleteItem(ctx, azcosmos.NewPartitionKeyString(uid), id, nil)
	if err != nil {
		return false, err
	}

	return true, nil
}

// ImportShoppingHistoryToFridge is the resolver for the importShoppingHistoryToFridge field.
func (r *mutationResolver) ImportShoppingHistoryToFridge(ctx context.Context, id string) (*model.ShoppingHistoryEntry, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	entry, err := r.FetchShoppingHistory(ctx, id)
	if err != nil {
		return nil, err
	}

	if entry.AuthorID != uid {
		return nil, fmt.Errorf("unauthorized")
	}

	if entry.IsImported {
		return nil, fmt.Errorf("history already imported")
	}

	fridge, err := r.FetchFridge(ctx, uid)
	if err != nil {
		return nil, err
	}

	now := time.Now()
	for _, histItem := range entry.ItemsSnapshot {
		price := histItem.Price
		newItem := &model.InventoryItem{
			ID:               "User@" + uuid.New().String(),
			Name:             histItem.Name,
			Quantity:         &model.Quantity{Value: histItem.Quantity, Unit: histItem.Unit},
			VirtualAvailable: histItem.Quantity,
			Price:            &price,
			Status:           model.ItemStatusAvailable,
			ExpiryDate:       histItem.ExpiryDate,
			ExpiryType:       histItem.ExpiryType,
			AddedAt:          now.Format(time.RFC3339),
			ActiveLocks:      []*model.ProductLock{},
		}

		if histItem.Category != nil {
			newItem.Category = histItem.Category
		}
		if histItem.Brand != nil {
			newItem.Brand = histItem.Brand
		}

		fridge.Items = append(fridge.Items, newItem)
	}

	if err := r.UpsertFridge(ctx, fridge); err != nil {
		return nil, err
	}

	entry.IsImported = true
	if err := r.UpsertShoppingHistory(ctx, entry); err != nil {
		// If saving history fails, we have a partial state (Items added, but history not marked)
		// Usually we'd want a transaction, but Cosmos only supports transactions within same partition key.
		// History PK = userId, Fridge PK = userId.
		// So we COULD use a transaction if they are in the same container, but they likely aren't.
		// For now, accept the risk or add logic. User didn't specify transactional strictness.
		// We'll log error.
		fmt.Printf("Error marking history as imported: %v\n", err)
		return nil, err
	}

	return entry, nil
}

// CreateShoppingHistoryFromStaging is the resolver for the createShoppingHistoryFromStaging field.
func (r *mutationResolver) CreateShoppingHistoryFromStaging(ctx context.Context, sessionID string) (*model.ShoppingHistoryEntry, error) {
	panic(fmt.Errorf("not implemented: CreateShoppingHistoryFromStaging - createShoppingHistoryFromStaging"))
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	return r.FetchUser(ctx, uid)
}

// MyFridge is the resolver for the myFridge field.
func (r *queryResolver) MyFridge(ctx context.Context) (*model.Fridge, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}
	return r.FetchFridge(ctx, uid)
}

// CurrentStagingSession is the resolver for the currentStagingSession field.
func (r *queryResolver) CurrentStagingSession(ctx context.Context) (*model.StagingSession, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	session, err := r.Logic.FetchUserStagingSession(ctx, uid)
	if err != nil {
		// We optimistically assume an error means no session exists or it's not retrievable,
		// so we return null to the frontend instead of blowing up.
		return nil, nil
	}

	// Sign the receiptImageUrl for secure read access
	if session != nil && session.ReceiptImageURL != nil && *session.ReceiptImageURL != "" {
		signedURL, signErr := r.signReceiptURL(ctx, *session.ReceiptImageURL)
		if signErr == nil {
			session.ReceiptImageURL = &signedURL
		}
	}

	return session, nil
}

// ShoppingHistory is the resolver for the shoppingHistory field.
func (r *queryResolver) ShoppingHistory(ctx context.Context, limit *int32, offset *int32) ([]*model.ShoppingHistoryEntry, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	l := 10
	if limit != nil {
		l = int(*limit)
	}
	o := 0
	if offset != nil {
		o = int(*offset)
	}

	entries, err := r.FetchShoppingHistoryList(ctx, uid, l, o)
	if err != nil {
		return nil, err
	}

	// Sign receiptImageUrl for each entry
	for _, entry := range entries {
		if entry.ReceiptImageURL != nil && *entry.ReceiptImageURL != "" {
			signedURL, signErr := r.signReceiptURL(ctx, *entry.ReceiptImageURL)
			if signErr == nil {
				entry.ReceiptImageURL = &signedURL
			}
		}
	}

	return entries, nil
}

// MyRecipes is the resolver for the myRecipes field.
func (r *queryResolver) MyRecipes(ctx context.Context, status *model.RecipeStatus) ([]*model.Recipe, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	query := "SELECT * FROM c WHERE c.authorId = @uid"
	if status != nil {
		query += fmt.Sprintf(" AND c.status = '%s'", *status)
	}

	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerCookbook)
	if err != nil {
		return nil, err
	}

	qOpts := azcosmos.QueryOptions{
		QueryParameters: []azcosmos.QueryParameter{
			{Name: "@uid", Value: uid},
		},
	}

	// Use PK = AuthorID = uid
	pager := container.NewQueryItemsPager(query, azcosmos.NewPartitionKeyString(uid), &qOpts)

	var recipes []*model.Recipe
	for pager.More() {
		resp, err := pager.NextPage(ctx)
		if err != nil {
			return nil, err
		}
		for _, bytes := range resp.Items {
			var recipe model.Recipe
			if err := json.Unmarshal(bytes, &recipe); err == nil {
				recipes = append(recipes, &recipe)
			}
		}
	}
	return recipes, nil
}

// Recipe is the resolver for the recipe field.
func (r *queryResolver) Recipe(ctx context.Context, id string) (*model.Recipe, error) {
	return r.FetchRecipe(ctx, id)
}

// Feed is the resolver for the feed field.
func (r *queryResolver) Feed(ctx context.Context, limit *int32, offset *int32) ([]*model.Post, error) {
	// Cross-partition query on PK /type = 'post'
	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerSocial)
	if err != nil {
		return nil, err
	}

	query := "SELECT * FROM c WHERE c.type = 'post' ORDER BY c.createdAt DESC"

	qOpts := azcosmos.QueryOptions{}

	// Use PK = 'post'
	pager := container.NewQueryItemsPager(query, azcosmos.NewPartitionKeyString("post"), &qOpts)

	var posts []*model.Post
	for pager.More() {
		resp, err := pager.NextPage(ctx)
		if err != nil {
			return nil, err
		}
		for _, bytes := range resp.Items {
			var post model.Post
			if err := json.Unmarshal(bytes, &post); err == nil {
				posts = append(posts, &post)
			}
		}
		if limit != nil && len(posts) >= int(100) { // Safety break
			break
		}
	}

	start := 0
	if offset != nil {
		start = int(*offset)
	}
	end := len(posts)
	if limit != nil {
		l := int(*limit)
		if start+l < end {
			end = start + l
		}
	} else {
		if start+20 < end {
			end = start + 20
		}
	}

	if start > len(posts) {
		return []*model.Post{}, nil
	}
	if end > len(posts) {
		end = len(posts)
	}
	if start > end {
		return []*model.Post{}, nil
	}

	return posts[start:end], nil
}

// Leaderboard is the resolver for the leaderboard field.
func (r *queryResolver) Leaderboard(ctx context.Context, top *int32) ([]*model.LeaderboardEntry, error) {
	limit := 5
	if top != nil {
		limit = int(*top)
	}
	return r.FetchLeaderboard(ctx, limit)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
