package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"encoding/json"
	"fmt"
	"regexp"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/data/azcosmos"
	"github.com/google/uuid"
	"github.com/mariocosenza/mocc/graph/model"
)

// UpdateUserPreferences is the resolver for the updateUserPreferences field.
func (r *mutationResolver) UpdateUserPreferences(ctx context.Context, input model.UserPreferencesInput) (*model.User, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.getUser(ctx, uid)
	if err != nil {
		return nil, err
	}

	if input.Currency != nil {
		user.Preferences.Currency = *input.Currency
	}
	if input.DefaultPortions != nil {
		user.Preferences.DefaultPortions = input.DefaultPortions
	}
	if input.DietaryRestrictions != nil {
		user.Preferences.DietaryRestrictions = input.DietaryRestrictions
	}

	if err := r.saveUserToCosmos(ctx, user); err != nil {
		return nil, err
	}
	r.cacheUser(ctx, user)

	return user, nil
}

// UpdateNickname is the resolver for the updateNickname field.
func (r *mutationResolver) UpdateNickname(ctx context.Context, nickname string) (*model.User, error) {
	if nickname == "" {
		return nil, fmt.Errorf("nickname cannot be empty")
	}

	// Validate allowed characters (letters, numbers, underscores)
	validNickname := regexp.MustCompile(`^[a-zA-Z0-9_]+$`)
	if !validNickname.MatchString(nickname) {
		return nil, fmt.Errorf("nickname can only contain letters, numbers, and underscores")
	}

	uuid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}
	r.updateNickname(ctx, uuid, nickname)

	// Propagate nickname to Social Posts
	// 1. Update posts where user is author
	container, err := r.Cosmos.NewContainer(cosmosDatabase, containerSocial)
	if err == nil {
		pk := azcosmos.NewPartitionKeyString("post")
		uidParam := azcosmos.QueryParameter{Name: "@uid", Value: uuid}
		queryOpts := &azcosmos.QueryOptions{
			QueryParameters: []azcosmos.QueryParameter{uidParam},
		}

		// Query 1: Author
		pager := container.NewQueryItemsPager("SELECT * FROM c WHERE c.authorId = @uid", pk, queryOpts)
		for pager.More() {
			resp, err := pager.NextPage(ctx)
			if err != nil {
				fmt.Printf("Error paging posts: %v\n", err)
				break
			}
			for _, bytes := range resp.Items {
				var post model.Post
				if err := json.Unmarshal(bytes, &post); err == nil {
					if post.AuthorNickname != nickname {
						post.AuthorNickname = nickname
						// Also check comments while we are here to save a write
						for _, c := range post.Comments {
							if c.UserID == uuid {
								c.UserNickname = nickname
							}
						}

						updatedBytes, _ := json.Marshal(post)
						// Helper map to preserve "type": "post"
						var postMap map[string]interface{}
						json.Unmarshal(updatedBytes, &postMap)
						postMap["type"] = "post"
						finalBytes, _ := json.Marshal(postMap)

						if _, err := container.UpsertItem(ctx, pk, finalBytes, nil); err != nil {
							fmt.Printf("Error updating post %s: %v\n", post.ID, err)
						} else {
							fmt.Printf("Successfully updated nickname in post %s\n", post.ID)
						}
					}
				}
			}
		}

		// Query 2: Commenter (and not Author, to avoid double write, though double write is safe but wasteful)
		// SELECT * FROM c WHERE ARRAY_CONTAINS(c.comments, {'userId': @uid}, true) AND c.authorId != @uid
		pagerComments := container.NewQueryItemsPager("SELECT * FROM c WHERE ARRAY_CONTAINS(c.comments, {'userId': @uid}, true) AND c.authorId != @uid", pk, queryOpts)
		for pagerComments.More() {
			resp, err := pagerComments.NextPage(ctx)
			if err != nil {
				break
			}
			for _, bytes := range resp.Items {
				var post model.Post
				if err := json.Unmarshal(bytes, &post); err == nil {
					updated := false
					for _, c := range post.Comments {
						if c.UserID == uuid && c.UserNickname != nickname {
							c.UserNickname = nickname
							updated = true
						}
					}

					if updated {
						updatedBytes, _ := json.Marshal(post)
						var postMap map[string]interface{}
						json.Unmarshal(updatedBytes, &postMap)
						postMap["type"] = "post"
						finalBytes, _ := json.Marshal(postMap)
						if _, err := container.UpsertItem(ctx, pk, finalBytes, nil); err != nil {
							fmt.Printf("Error updating post comment %s: %v\n", post.ID, err)
						} else {
							fmt.Printf("Successfully updated nickname in post comment %s\n", post.ID)
						}
					}
				}
			}
		}
	} else {
		fmt.Printf("Error getting social container: %v\n", err)
	}

	return r.getUser(ctx, uuid)
}

// AddInventoryItem is the resolver for the addInventoryItem field.
func (r *mutationResolver) AddInventoryItem(ctx context.Context, input model.AddInventoryItemInput) (*model.InventoryItem, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	fridge, err := r.getFridge(ctx, uid)
	if err != nil {
		return nil, err
	}

	now := time.Now()
	newItem := &model.InventoryItem{
		ID:               "User@" + uuid.New().String(),
		Name:             input.Name,
		Brand:            input.Brand,
		Category:         input.Category,
		Quantity:         &model.Quantity{Value: input.Quantity.Value, Unit: input.Quantity.Unit},
		VirtualAvailable: input.Quantity.Value,
		Price:            input.Price,
		Status:           model.ItemStatusAvailable,
		ExpiryDate:       input.ExpiryDate, // Assuming DateTime scalar is string compat
		ExpiryType:       input.ExpiryType,
		AddedAt:          now.Format(time.RFC3339),
		ActiveLocks:      []*model.ProductLock{},
	}
	if input.Status != nil {
		newItem.Status = *input.Status
	}

	fridge.Items = append(fridge.Items, newItem)

	if err := r.saveFridge(ctx, fridge); err != nil {
		return nil, err
	}

	return newItem, nil
}

// UpdateInventoryItem is the resolver for the updateInventoryItem field.
func (r *mutationResolver) UpdateInventoryItem(ctx context.Context, id string, input model.UpdateInventoryItemInput) (*model.InventoryItem, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	fridge, err := r.getFridge(ctx, uid)
	if err != nil {
		return nil, err
	}

	var item *model.InventoryItem
	for _, i := range fridge.Items {
		if i.ID == id {
			item = i
			break
		}
	}
	if item == nil {
		return nil, fmt.Errorf(errItemNotFound)
	}

	if input.Name != nil {
		item.Name = *input.Name
	}
	if input.Brand != nil {
		item.Brand = input.Brand
	}
	if input.Category != nil {
		item.Category = input.Category
	}
	if input.Price != nil {
		item.Price = input.Price
	}
	if input.Status != nil {
		item.Status = *input.Status
	}
	if input.Quantity != nil {

		item.Quantity = &model.Quantity{Value: input.Quantity.Value, Unit: input.Quantity.Unit}

		// Recalculate virtual available based on new quantity
		item.VirtualAvailable = item.Quantity.Value
		for _, l := range item.ActiveLocks {
			item.VirtualAvailable -= l.Amount
		}
	}
	if input.ExpiryDate != nil {
		item.ExpiryDate = *input.ExpiryDate
	}
	if input.ExpiryType != nil {
		item.ExpiryType = *input.ExpiryType
	}

	if err := r.saveFridge(ctx, fridge); err != nil {
		return nil, err
	}

	return item, nil
}

// DeleteInventoryItem is the resolver for the deleteInventoryItem field.
func (r *mutationResolver) DeleteInventoryItem(ctx context.Context, id string) (bool, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return false, err
	}

	fridge, err := r.getFridge(ctx, uid)
	if err != nil {
		return false, err
	}

	newItems := []*model.InventoryItem{}
	found := false
	for _, i := range fridge.Items {
		if i.ID == id {
			if len(i.ActiveLocks) > 0 {
				return false, fmt.Errorf("cannot delete item %s because it is used in active recipes", i.Name)
			}
			found = true
			continue
		}
		newItems = append(newItems, i)
	}

	if !found {
		return false, nil
	}

	fridge.Items = newItems
	if err := r.saveFridge(ctx, fridge); err != nil {
		return false, err
	}

	return true, nil
}

// ConsumeInventoryItem is the resolver for the consumeInventoryItem field.
func (r *mutationResolver) ConsumeInventoryItem(ctx context.Context, id string, amount float64) (*model.InventoryItem, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	fridge, err := r.getFridge(ctx, uid)
	if err != nil {
		return nil, err
	}

	var item *model.InventoryItem
	var itemIndex int
	for i, it := range fridge.Items {
		if it.ID == id {
			item = it
			itemIndex = i
			break
		}
	}
	if item == nil {
		return nil, fmt.Errorf(errItemNotFound)
	}

	newVal := item.Quantity.Value - amount
	if newVal < 0 {
		return nil, fmt.Errorf("insufficient quantity")
	}
	item.Quantity.Value = newVal
	item.VirtualAvailable = newVal

	if newVal == 0 {
		if len(item.ActiveLocks) > 0 {
			return nil, fmt.Errorf("cannot consume item %s completely because it is used in active recipes", item.Name)
		}
		fridge.Items = append(fridge.Items[:itemIndex], fridge.Items[itemIndex+1:]...)
	}

	if err := r.saveFridge(ctx, fridge); err != nil {
		return nil, err
	}

	return item, nil
}

// WasteInventoryItem is the resolver for the wasteInventoryItem field.
func (r *mutationResolver) WasteInventoryItem(ctx context.Context, id string, amount float64, reason *string) (*model.InventoryItem, error) {
	return r.ConsumeInventoryItem(ctx, id, amount)
}

// CreateStagingSession is the resolver for the createStagingSession field.
func (r *mutationResolver) CreateStagingSession(ctx context.Context, receiptImageURL *string) (*model.StagingSession, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	sessionID := uuid.New().String()
	now := time.Now()

	session := &model.StagingSession{
		ID:        sessionID,
		Items:     []*model.StagingItem{},
		CreatedAt: now.Format(time.RFC3339),
		ExpiresAt: now.Add(24 * time.Hour).Format(time.RFC3339),
	}
	if receiptImageURL != nil {
		session.Items = append(session.Items, &model.StagingItem{
			ID:            uuid.New().String(),
			Name:          "Detected Apple",
			DetectedPrice: &[]float64{1.50}[0],
			Quantity:      &[]int32{2}[0],
			Confidence:    &[]float64{0.95}[0],
		})
	}

	if err := r.saveStagingSession(ctx, session); err != nil {
		return nil, err
	}
	if err := r.setUserStagingSession(ctx, uid, sessionID); err != nil {
		return nil, err
	}

	return session, nil
}

// AddItemToStaging is the resolver for the addItemToStaging field.
func (r *mutationResolver) AddItemToStaging(ctx context.Context, sessionID string, name string, quantity *int32) (*model.StagingItem, error) {
	// ...
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	currentSessID, err := r.getUserStagingSessionID(ctx, uid)
	if err != nil || currentSessID != sessionID {
		return nil, fmt.Errorf("session not found or access denied")
	}

	session, err := r.getStagingSession(ctx, sessionID)
	if err != nil {
		return nil, err
	}

	item := &model.StagingItem{
		ID:       uuid.New().String(),
		Name:     name,
		Quantity: quantity,
	}
	session.Items = append(session.Items, item)

	if err := r.saveStagingSession(ctx, session); err != nil {
		return nil, err
	}
	return item, nil
}

// UpdateStagingItem is the resolver for the updateStagingItem field.
func (r *mutationResolver) UpdateStagingItem(ctx context.Context, sessionID string, itemID string, input model.StagingItemInput) (*model.StagingItem, error) {
	session, err := r.getStagingSession(ctx, sessionID)
	if err != nil {
		return nil, err
	}

	var item *model.StagingItem
	for _, i := range session.Items {
		if i.ID == itemID {
			item = i
			break
		}
	}
	if item == nil {
		return nil, fmt.Errorf("item not found")
	}

	if input.Name != nil {
		item.Name = *input.Name
	}
	if input.Quantity != nil {
		item.Quantity = input.Quantity
	}
	if input.DetectedPrice != nil {
		item.DetectedPrice = input.DetectedPrice
	}

	if err := r.saveStagingSession(ctx, session); err != nil {
		return nil, err
	}
	return item, nil
}

// DeleteStagingItem is the resolver for the deleteStagingItem field.
func (r *mutationResolver) DeleteStagingItem(ctx context.Context, sessionID string, itemID string) (bool, error) {
	session, err := r.getStagingSession(ctx, sessionID)
	if err != nil {
		return false, err
	}

	newItems := []*model.StagingItem{}
	found := false
	for _, i := range session.Items {
		if i.ID == itemID {
			found = true
			continue
		}
		newItems = append(newItems, i)
	}
	if !found {
		return false, nil
	}

	session.Items = newItems
	if err := r.saveStagingSession(ctx, session); err != nil {
		return false, err
	}
	return true, nil
}

// CommitStagingSession is the resolver for the commitStagingSession field.
func (r *mutationResolver) CommitStagingSession(ctx context.Context, sessionID string) ([]*model.InventoryItem, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	session, err := r.getStagingSession(ctx, sessionID)
	if err != nil {
		return nil, err
	}

	// Add items to Fridge
	fridge, err := r.getFridge(ctx, uid)
	if err != nil {
		return nil, err
	}

	addedItems := []*model.InventoryItem{}
	now := time.Now()

	for _, sItem := range session.Items {
		qty := int32(1)
		if sItem.Quantity != nil {
			qty = *sItem.Quantity
		}

		newItem := &model.InventoryItem{
			ID:               uuid.New().String(),
			Name:             sItem.Name,
			Quantity:         &model.Quantity{Value: float64(qty), Unit: model.UnitPz}, // Default unit
			VirtualAvailable: float64(qty),
			Price:            sItem.DetectedPrice,
			Status:           model.ItemStatusAvailable,
			ExpiryDate:       now.Add(7 * 24 * time.Hour).Format(time.RFC3339), // Default expiry 1 week
			ExpiryType:       model.ExpiryTypeBestBefore,
			AddedAt:          now.Format(time.RFC3339),
			ActiveLocks:      []*model.ProductLock{},
		}
		fridge.Items = append(fridge.Items, newItem)
		addedItems = append(addedItems, newItem)
	}

	if err := r.saveFridge(ctx, fridge); err != nil {
		return nil, err
	}

	// Cleanup session
	r.clearUserStagingSession(ctx, uid)
	r.Redis.Del(ctx, "staging:session:"+sessionID)

	return addedItems, nil
}

// DiscardStagingSession is the resolver for the discardStagingSession field.
func (r *mutationResolver) DiscardStagingSession(ctx context.Context, sessionID string) (bool, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return false, err
	}
	r.clearUserStagingSession(ctx, uid)
	r.Redis.Del(ctx, "staging:session:"+sessionID)
	return true, nil
}

// CreateRecipe is the resolver for the createRecipe field.
func (r *mutationResolver) CreateRecipe(ctx context.Context, input model.CreateRecipeInput) (*model.Recipe, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	ingredients := []*model.RecipeIngredient{}
	for _, i := range input.Ingredients {
		ingredients = append(ingredients, &model.RecipeIngredient{
			Name:                i.Name,
			Quantity:            i.Quantity,
			Unit:                i.Unit,
			InventoryItemID:     i.InventoryItemID,
			IsAvailableInFridge: false, // Calculated on read usually
		})
	}

	steps := []string{}
	if input.Steps != nil {
		steps = input.Steps
	}

	desc := ""
	if input.Description != nil {
		desc = *input.Description
	}

	newRecipe := &model.Recipe{
		ID:              uuid.New().String(),
		AuthorID:        uid,
		Title:           input.Title,
		Description:     desc,
		Status:          model.RecipeStatusProposed,
		Ingredients:     ingredients,
		Steps:           steps,
		PrepTimeMinutes: input.PrepTimeMinutes,
		Calories:        input.Calories,
		EcoPointsReward: input.EcoPointsReward,
		GeneratedByAi:   false,
	}

	newRecipe.Status = model.RecipeStatusProposed

	if err := r.lockRecipeIngredients(ctx, uid, newRecipe); err != nil {
		return nil, err
	}

	if err := r.saveRecipe(ctx, newRecipe); err != nil {
		return nil, err
	}

	return newRecipe, nil
}

// UpdateRecipe is the resolver for the updateRecipe field.
func (r *mutationResolver) UpdateRecipe(ctx context.Context, id string, input model.UpdateRecipeInput) (*model.Recipe, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	recipe, err := r.getRecipe(ctx, id)
	if err != nil {
		return nil, err
	}

	if recipe.AuthorID != uid {
		return nil, fmt.Errorf("unauthorized")
	}

	if recipe.Status == model.RecipeStatusCooked {
		return nil, fmt.Errorf("cannot modify a cooked recipe")
	}

	if recipe.GeneratedByAi {
		return nil, fmt.Errorf("cannot modify AI generated recipe")
	}

	if input.Title != nil {
		recipe.Title = *input.Title
	}
	if input.Description != nil {
		recipe.Description = *input.Description
	}
	ingredientsChanged := false
	if input.Ingredients != nil {
		ingredients := []*model.RecipeIngredient{}
		for _, i := range input.Ingredients {
			ingredients = append(ingredients, &model.RecipeIngredient{
				Name:            i.Name,
				Quantity:        i.Quantity,
				Unit:            i.Unit,
				InventoryItemID: i.InventoryItemID,
			})
		}
		recipe.Ingredients = ingredients
		ingredientsChanged = true
	}
	if input.Steps != nil {
		recipe.Steps = input.Steps
	}
	if input.PrepTimeMinutes != nil {
		recipe.PrepTimeMinutes = input.PrepTimeMinutes
	}
	if input.Calories != nil {
		recipe.Calories = input.Calories
	}
	isOldStateActive := (recipe.Status == model.RecipeStatusInPreparation || recipe.Status == model.RecipeStatusProposed)
	isNewStateActive := (input.Status == nil || *input.Status == model.RecipeStatusInPreparation || *input.Status == model.RecipeStatusProposed)

	if ingredientsChanged && isOldStateActive && isNewStateActive {
		if err := r.unlockRecipeIngredients(ctx, uid, recipe.ID); err != nil {
			return nil, err
		}
		if err := r.lockRecipeIngredients(ctx, uid, recipe); err != nil {
			return nil, err
		}
	}

	if input.Status != nil {
		oldStatus := recipe.Status
		newStatus := *input.Status

		if newStatus != oldStatus {
			if newStatus == model.RecipeStatusInPreparation || newStatus == model.RecipeStatusProposed {
				if err := r.lockRecipeIngredients(ctx, uid, recipe); err != nil {
					return nil, err
				}
			}

			if newStatus == model.RecipeStatusCooked {
				if err := r.unlockRecipeIngredients(ctx, uid, recipe.ID); err != nil {
					return nil, err
				}

				if err := r.completeRecipeCooking(ctx, uid, recipe); err != nil {
					return nil, err
				}

				points := int32(0)
				if recipe.EcoPointsReward != nil {
					points = *recipe.EcoPointsReward
				}

				if points > 0 {
					user, err := r.getUser(ctx, uid)
					if err != nil {
						return nil, err
					}

					if user.Gamification == nil {
						user.Gamification = &model.GamificationProfile{
							CurrentLevel:       1,
							NextLevelThreshold: 100,
						}
					}

					user.Gamification.TotalEcoPoints += points

					user.Gamification.TotalEcoPoints += points
					r.checkAndApplyLevelUp(user)

					if err := r.saveUserToCosmos(ctx, user); err != nil {
						return nil, err
					}

					r.updateLeaderboard(ctx, user)
					r.cacheUser(ctx, user)
				}
			}
		}
		recipe.Status = *input.Status
	}

	if err := r.saveRecipe(ctx, recipe); err != nil {
		return nil, err
	}

	return recipe, nil
}

// DeleteRecipe is the resolver for the deleteRecipe field.
func (r *mutationResolver) DeleteRecipe(ctx context.Context, id string) (bool, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return false, err
	}

	// Just check if it exists and author matches
	recipe, err := r.getRecipe(ctx, id)
	if err != nil {
		return false, err
	}

	if recipe.AuthorID != uid {
		return false, fmt.Errorf("unauthorized")
	}

	// Only unlock if the recipe was NOT cooked.
	// If it is cooked, the ingredients are consumed and should not be restored.
	if recipe.Status != model.RecipeStatusCooked {
		if err := r.unlockRecipeIngredients(ctx, uid, recipe.ID); err != nil {
			return false, err
		}
	}

	container, err := r.Cosmos.NewContainer(cosmosDatabase, containerCookbook)
	if err != nil {
		return false, err
	}

	// Delete needs PK which is AuthorID
	_, err = container.DeleteItem(ctx, azcosmos.NewPartitionKeyString(recipe.AuthorID), id, nil)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CookRecipe is the resolver for the cookRecipe field.
func (r *mutationResolver) CookRecipe(ctx context.Context, id string) (*model.Recipe, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	recipe, err := r.getRecipe(ctx, id)
	if err != nil {
		return nil, err
	}

	if recipe.AuthorID != uid {
		return nil, fmt.Errorf("unauthorized")
	}

	if recipe.Status == model.RecipeStatusCooked {
		return recipe, nil
	}

	// Always unlock first to release any existing reservations (if it was InPreparation)
	if err := r.unlockRecipeIngredients(ctx, uid, recipe.ID); err != nil {
		return nil, err
	}

	if err := r.completeRecipeCooking(ctx, uid, recipe); err != nil {
		return nil, err
	}

	recipe.Status = model.RecipeStatusCooked
	if err := r.saveRecipe(ctx, recipe); err != nil {
		return nil, err
	}

	return recipe, nil
}

// SaveRecipe is the resolver for the saveRecipe field.
func (r *mutationResolver) SaveRecipe(ctx context.Context, id string) (*model.Recipe, error) {
	panic(fmt.Errorf("not implemented: SaveRecipe - saveRecipe"))
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.CreatePostInput) (*model.Post, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	// Verify recipe exists
	recipe, err := r.getRecipe(ctx, input.RecipeID)
	if err != nil {
		return nil, fmt.Errorf("recipe not found")
	}

	// Get Author details
	author, err := r.getUser(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("user not found")
	}

	// Create Snapshot
	ings := []*model.RecipeIngredientSnapshot{}
	for _, i := range recipe.Ingredients {
		ings = append(ings, &model.RecipeIngredientSnapshot{
			Name:     i.Name,
			Quantity: i.Quantity,
			Unit:     i.Unit,
		})
	}

	desc := recipe.Description
	snapshot := &model.RecipeSnapshot{
		Title:           recipe.Title,
		Description:     &desc,
		Ingredients:     ings,
		Steps:           recipe.Steps,
		PrepTimeMinutes: recipe.PrepTimeMinutes,
		Calories:        recipe.Calories,
		EcoPointsReward: recipe.EcoPointsReward,
	}

	postID := uuid.New().String()
	now := time.Now().Format(time.RFC3339)

	imgURL := ""
	if input.ImageURL != nil {
		imgURL = *input.ImageURL
	}

	newPost := &model.Post{
		ID:             postID,
		AuthorID:       uid,
		AuthorNickname: author.Nickname,
		RecipeSnapshot: snapshot,
		Caption:        input.Caption,
		ImageURL:       &imgURL,
		LikesCount:     0,
		LikedBy:        []string{},
		CreatedAt:      now,
		Comments:       []*model.Comment{},
	}

	container, err := r.Cosmos.NewContainer(cosmosDatabase, containerSocial)
	if err != nil {
		return nil, err
	}

	// Use map to include "type" field for partition key logic

	postMap := map[string]interface{}{}
	b, _ := json.Marshal(newPost)
	json.Unmarshal(b, &postMap)
	postMap["type"] = "post"

	data, err := json.Marshal(postMap)
	if err != nil {
		return nil, err
	}

	_, err = container.UpsertItem(ctx, azcosmos.NewPartitionKeyString("post"), data, nil)
	if err != nil {
		return nil, err
	}

	// Award points
	if author.Gamification == nil {
		// Load user again? We have author.
		author.Gamification = &model.GamificationProfile{TotalEcoPoints: 0, CurrentLevel: 1, NextLevelThreshold: 100}
	}
	author.Gamification.TotalEcoPoints += 10
	if err := r.saveUserToCosmos(ctx, author); err == nil {
		r.updateLeaderboard(ctx, author)
		r.cacheUser(ctx, author)
	}

	return newPost, nil
}

// UpdatePost is the resolver for the updatePost field.
func (r *mutationResolver) UpdatePost(ctx context.Context, id string, caption string) (*model.Post, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	container, err := r.Cosmos.NewContainer(cosmosDatabase, containerSocial)
	if err != nil {
		return nil, err
	}

	// Read Post
	var post model.Post
	resp, err := container.ReadItem(ctx, azcosmos.NewPartitionKeyString("post"), id, nil)
	if err != nil {
		return nil, err
	}
	if err := json.Unmarshal(resp.Value, &post); err != nil {
		return nil, err
	}

	// Check Authorization
	if post.AuthorID != uid {
		return nil, fmt.Errorf("unauthorized")
	}

	// Update logic
	post.Caption = &caption

	// Save back (preserving "type"="post")
	postMap := map[string]interface{}{}
	b, _ := json.Marshal(post)
	json.Unmarshal(b, &postMap)
	postMap["type"] = "post"

	finalData, _ := json.Marshal(postMap)
	_, err = container.UpsertItem(ctx, azcosmos.NewPartitionKeyString("post"), finalData, nil)
	if err != nil {
		return nil, err
	}

	return &post, nil
}

// DeletePost is the resolver for the deletePost field.
func (r *mutationResolver) DeletePost(ctx context.Context, id string) (bool, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return false, err
	}

	container, err := r.Cosmos.NewContainer(cosmosDatabase, containerSocial)
	if err != nil {
		return false, err
	}

	// PK is "post"
	itemResponse, err := container.ReadItem(ctx, azcosmos.NewPartitionKeyString("post"), id, nil)
	if err != nil {
		return false, err
	}

	var postData map[string]interface{}
	if err := json.Unmarshal(itemResponse.Value, &postData); err != nil {
		return false, err
	}

	authorId, ok := postData["authorId"].(string)
	if !ok || authorId != uid {
		return false, fmt.Errorf("unauthorized")
	}

	_, err = container.DeleteItem(ctx, azcosmos.NewPartitionKeyString("post"), id, nil)
	return err == nil, err
}

// LikePost is the resolver for the likePost field.
func (r *mutationResolver) LikePost(ctx context.Context, postID string) (*model.Post, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	container, err := r.Cosmos.NewContainer(cosmosDatabase, containerSocial)
	if err != nil {
		return nil, err
	}

	// Read Post
	var post model.Post // Note: this won't have "type", but that's fine for unmarshal
	resp, err := container.ReadItem(ctx, azcosmos.NewPartitionKeyString("post"), postID, nil)
	if err != nil {
		return nil, err
	}
	if err := json.Unmarshal(resp.Value, &post); err != nil {
		return nil, err
	}

	// Check if already liked
	alreadyLiked := false
	for _, id := range post.LikedBy {
		if id == uid {
			alreadyLiked = true
			break
		}
	}

	if !alreadyLiked {
		post.LikedBy = append(post.LikedBy, uid)
		post.LikesCount = int32(len(post.LikedBy))

		// Save back (preserving "type"="post")
		postMap := map[string]interface{}{}
		b, _ := json.Marshal(post)
		json.Unmarshal(b, &postMap)
		postMap["type"] = "post"

		finalData, _ := json.Marshal(postMap)
		_, err = container.UpsertItem(ctx, azcosmos.NewPartitionKeyString("post"), finalData, nil)
		if err != nil {
			return nil, err
		}
	}

	return &post, nil
}

// UnlikePost is the resolver for the unlikePost field.
func (r *mutationResolver) UnlikePost(ctx context.Context, postID string) (*model.Post, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	container, err := r.Cosmos.NewContainer(cosmosDatabase, containerSocial)
	if err != nil {
		return nil, err
	}

	var post model.Post
	resp, err := container.ReadItem(ctx, azcosmos.NewPartitionKeyString("post"), postID, nil)
	if err != nil {
		return nil, err
	}
	if err := json.Unmarshal(resp.Value, &post); err != nil {
		return nil, err
	}

	newLikedBy := []string{}
	found := false
	for _, id := range post.LikedBy {
		if id == uid {
			found = true
			continue
		}
		newLikedBy = append(newLikedBy, id)
	}

	if found {
		post.LikedBy = newLikedBy
		post.LikesCount = int32(len(post.LikedBy))

		postMap := map[string]interface{}{}
		b, _ := json.Marshal(post)
		json.Unmarshal(b, &postMap)
		postMap["type"] = "post"

		finalData, _ := json.Marshal(postMap)
		_, err = container.UpsertItem(ctx, azcosmos.NewPartitionKeyString("post"), finalData, nil)
		if err != nil {
			return nil, err
		}
	}

	return &post, nil
}

// AddComment is the resolver for the addComment field.
func (r *mutationResolver) AddComment(ctx context.Context, postID string, text string) (*model.Comment, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.getUser(ctx, uid)
	if err != nil {
		return nil, err
	}

	container, err := r.Cosmos.NewContainer(cosmosDatabase, containerSocial)
	if err != nil {
		return nil, err
	}

	var post model.Post
	resp, err := container.ReadItem(ctx, azcosmos.NewPartitionKeyString("post"), postID, nil)
	if err != nil {
		return nil, err
	}
	if err := json.Unmarshal(resp.Value, &post); err != nil {
		return nil, err
	}

	newComment := &model.Comment{
		ID:           uuid.New().String(),
		UserID:       uid,
		UserNickname: user.Nickname,
		Text:         text,
		CreatedAt:    time.Now().Format(time.RFC3339),
	}

	post.Comments = append(post.Comments, newComment)

	// Sort comments by date (newest first or oldest? User said "sort the comment by date")
	// Usually social comments are oldest first (thread) or newest first.
	// "post details... should be visible only when tapping... sort the comment by date"
	// I'll keep them appended, and maybe sort on display or insertion.
	// Appending puts it at end (latest). Default order usually fine.

	postMap := map[string]interface{}{}
	b, _ := json.Marshal(post)
	json.Unmarshal(b, &postMap)
	postMap["type"] = "post"

	finalData, _ := json.Marshal(postMap)
	_, err = container.UpsertItem(ctx, azcosmos.NewPartitionKeyString("post"), finalData, nil)
	if err != nil {
		return nil, err
	}

	return newComment, nil
}

// GenerateUploadSasToken is the resolver for the generateUploadSasToken field.
func (r *mutationResolver) GenerateUploadSasToken(ctx context.Context, filename string) (string, error) {
	// TODO: Implement actual SAS token generation using azblob
	// For now, return a placeholder or error
	// return "", fmt.Errorf("SAS token generation not configured yet")

	// Example of what it should look like:
	// sasQueryParams, err := sas.BlobSignatureValues{ ... }.Sign(credential)
	// return fmt.Sprintf("https://%s.blob.core.windows.net/%s/%s?%s", accountName, container, filename, sasQueryParams.Encode()), nil

	return "https://mockstorage.blob.core.windows.net/staging/" + filename + "?sv=2023-01-03&st=2023...", nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	return r.getUser(ctx, uid)
}

// MyFridge is the resolver for the myFridge field.
func (r *queryResolver) MyFridge(ctx context.Context) (*model.Fridge, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}
	return r.getFridge(ctx, uid)
}

// CurrentStagingSession is the resolver for the currentStagingSession field.
func (r *queryResolver) CurrentStagingSession(ctx context.Context) (*model.StagingSession, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	sessionID, err := r.getUserStagingSessionID(ctx, uid)
	if err != nil {
		return nil, nil // No active session
	}

	return r.getStagingSession(ctx, sessionID)
}

// ShoppingHistory is the resolver for the shoppingHistory field.
func (r *queryResolver) ShoppingHistory(ctx context.Context, limit *int32, offset *int32) ([]*model.ShoppingHistoryEntry, error) {
	// Not implemented yet
	return []*model.ShoppingHistoryEntry{}, nil
}

// MyRecipes is the resolver for the myRecipes field.
func (r *queryResolver) MyRecipes(ctx context.Context, status *model.RecipeStatus) ([]*model.Recipe, error) {
	uid, err := r.getUserID(ctx)
	if err != nil {
		return nil, err
	}

	query := "SELECT * FROM c WHERE c.authorId = @uid"
	if status != nil {
		query += fmt.Sprintf(" AND c.status = '%s'", *status)
	}

	container, err := r.Cosmos.NewContainer(cosmosDatabase, containerCookbook)
	if err != nil {
		return nil, err
	}

	qOpts := azcosmos.QueryOptions{
		QueryParameters: []azcosmos.QueryParameter{
			{Name: "@uid", Value: uid},
		},
	}

	// Use PK = AuthorID = uid
	pager := container.NewQueryItemsPager(query, azcosmos.NewPartitionKeyString(uid), &qOpts)

	var recipes []*model.Recipe
	for pager.More() {
		resp, err := pager.NextPage(ctx)
		if err != nil {
			return nil, err
		}
		for _, bytes := range resp.Items {
			var recipe model.Recipe
			if err := json.Unmarshal(bytes, &recipe); err == nil {
				recipes = append(recipes, &recipe)
			}
		}
	}
	return recipes, nil
}

// Recipe is the resolver for the recipe field.
func (r *queryResolver) Recipe(ctx context.Context, id string) (*model.Recipe, error) {
	return r.getRecipe(ctx, id)
}

// Feed is the resolver for the feed field.
func (r *queryResolver) Feed(ctx context.Context, limit *int32, offset *int32) ([]*model.Post, error) {
	// Cross-partition query on PK /type = 'post'
	container, err := r.Cosmos.NewContainer(cosmosDatabase, containerSocial)
	if err != nil {
		return nil, err
	}

	query := "SELECT * FROM c WHERE c.type = 'post' ORDER BY c.createdAt DESC"

	qOpts := azcosmos.QueryOptions{}

	// Use PK = 'post'
	pager := container.NewQueryItemsPager(query, azcosmos.NewPartitionKeyString("post"), &qOpts)

	var posts []*model.Post
	for pager.More() {
		resp, err := pager.NextPage(ctx)
		if err != nil {
			return nil, err
		}
		for _, bytes := range resp.Items {
			var post model.Post
			if err := json.Unmarshal(bytes, &post); err == nil {
				posts = append(posts, &post)
			}
		}
		if limit != nil && len(posts) >= int(100) { // Safety break
			break
		}
	}

	start := 0
	if offset != nil {
		start = int(*offset)
	}
	end := len(posts)
	if limit != nil {
		l := int(*limit)
		if start+l < end {
			end = start + l
		}
	} else {
		if start+20 < end {
			end = start + 20
		}
	}

	if start > len(posts) {
		return []*model.Post{}, nil
	}
	if end > len(posts) {
		end = len(posts)
	}
	if start > end {
		return []*model.Post{}, nil
	}

	return posts[start:end], nil
}

// Leaderboard is the resolver for the leaderboard field.
func (r *queryResolver) Leaderboard(ctx context.Context, top *int32) ([]*model.LeaderboardEntry, error) {
	limit := 5
	if top != nil {
		limit = int(*top)
	}
	return r.getLeaderboard(ctx, limit)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
