package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/Azure/azure-sdk-for-go/sdk/data/azcosmos"
	"github.com/mariocosenza/mocc/auth"
	"github.com/mariocosenza/mocc/graph/model"
)

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	cosmosClient := r.Cosmos
	container, err := cosmosClient.NewContainer("mocc-db", "Users")
	if err != nil {
		return nil, fmt.Errorf("failed to get cosmos container: %w", err)
	}
	
	userID := auth.GetUserID(ctx)
	if userID == "" {
		return nil, fmt.Errorf("unauthenticated user")
	}

	query := "SELECT * FROM c WHERE c.id = @id"
    queryOptions := azcosmos.QueryOptions{
        QueryParameters: []azcosmos.QueryParameter{
            {Name: "@id", Value: userID},
        },
    }

	queryPager := container.NewQueryItemsPager(query, azcosmos.NewPartitionKeyString(userID), &queryOptions)
	var users []model.User
	for queryPager.More() {
		queryResponse, err := queryPager.NextPage(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to query user: %w", err)
		}

		for _, item := range queryResponse.Items {
			var user model.User
			if err := json.Unmarshal(item, &user); err != nil {
				return nil, fmt.Errorf("failed to unmarshal user: %w", err)
			}
			users = append(users, user)
		}
	}

	if len(users) == 0 {
		return nil, fmt.Errorf("user not found")
	}

	return &users[0], nil	
	
}

// MyFridge is the resolver for the myFridge field.
func (r *queryResolver) MyFridge(ctx context.Context) (*model.Fridge, error) {
	panic(fmt.Errorf("not implemented: MyFridge - myFridge"))
}

// CurrentStagingSession is the resolver for the currentStagingSession field.
func (r *queryResolver) CurrentStagingSession(ctx context.Context) (*model.StagingSession, error) {
	panic(fmt.Errorf("not implemented: CurrentStagingSession - currentStagingSession"))
}

// ShoppingHistory is the resolver for the shoppingHistory field.
func (r *queryResolver) ShoppingHistory(ctx context.Context, limit *int32, offset *int32) ([]*model.ShoppingHistoryEntry, error) {
	panic(fmt.Errorf("not implemented: ShoppingHistory - shoppingHistory"))
}

// MyRecipes is the resolver for the myRecipes field.
func (r *queryResolver) MyRecipes(ctx context.Context, status *model.RecipeStatus) ([]*model.Recipe, error) {
	panic(fmt.Errorf("not implemented: MyRecipes - myRecipes"))
}

// Recipe is the resolver for the recipe field.
func (r *queryResolver) Recipe(ctx context.Context, id string) (*model.Recipe, error) {
	panic(fmt.Errorf("not implemented: Recipe - recipe"))
}

// Feed is the resolver for the feed field.
func (r *queryResolver) Feed(ctx context.Context, limit *int32, offset *int32) ([]*model.Post, error) {
	panic(fmt.Errorf("not implemented: Feed - feed"))
}

// Leaderboard is the resolver for the leaderboard field.
func (r *queryResolver) Leaderboard(ctx context.Context, top *int32) ([]*model.LeaderboardEntry, error) {
	panic(fmt.Errorf("not implemented: Leaderboard - leaderboard"))
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
