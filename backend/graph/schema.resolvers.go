package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/data/azcosmos"
	"github.com/Azure/azure-sdk-for-go/sdk/storage/azblob/sas"
	"github.com/google/uuid"
	"github.com/mariocosenza/mocc/graph/model"
	"github.com/mariocosenza/mocc/internal/logic"
)

// UpdateUserPreferences is the resolver for the updateUserPreferences field.
func (r *mutationResolver) UpdateUserPreferences(ctx context.Context, input model.UserPreferencesInput) (*model.User, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.FetchUser(ctx, uid)
	if err != nil {
		return nil, err
	}

	if input.Currency != nil {
		user.Preferences.Currency = *input.Currency
	}
	if input.DefaultPortions != nil {
		user.Preferences.DefaultPortions = input.DefaultPortions
	}
	if input.DietaryRestrictions != nil {
		user.Preferences.DietaryRestrictions = input.DietaryRestrictions
	}

	if err := r.UpsertUser(ctx, user); err != nil {
		return nil, err
	}
	r.SetUserCache(ctx, user)

	return user, nil
}

// UpdateNickname is the resolver for the updateNickname field.
func (r *mutationResolver) UpdateNickname(ctx context.Context, nickname string) (*model.User, error) {
	if nickname == "" {
		return nil, fmt.Errorf("nickname cannot be empty")
	}

	// Validate allowed characters (letters, numbers, underscores)
	validNickname := regexp.MustCompile(`^[a-zA-Z0-9_]+$`)
	if !validNickname.MatchString(nickname) {
		return nil, fmt.Errorf("nickname can only contain letters, numbers, and underscores")
	}

	uuid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}
	r.SyncNickname(ctx, uuid, nickname)

	// Propagate nickname to Social Posts
	// 1. Update posts where user is author
	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerSocial)
	if err == nil {
		pk := azcosmos.NewPartitionKeyString("post")
		uidParam := azcosmos.QueryParameter{Name: "@uid", Value: uuid}
		queryOpts := &azcosmos.QueryOptions{
			QueryParameters: []azcosmos.QueryParameter{uidParam},
		}

		// Query 1: Author
		pager := container.NewQueryItemsPager("SELECT * FROM c WHERE c.authorId = @uid", pk, queryOpts)
		for pager.More() {
			resp, err := pager.NextPage(ctx)
			if err != nil {
				fmt.Printf("Error paging posts: %v\n", err)
				break
			}
			for _, bytes := range resp.Items {
				var post model.Post
				if err := json.Unmarshal(bytes, &post); err == nil {
					if post.AuthorNickname != nickname {
						post.AuthorNickname = nickname
						// Also check comments while we are here to save a write
						for _, c := range post.Comments {
							if c.UserID == uuid {
								c.UserNickname = nickname
							}
						}

						updatedBytes, _ := json.Marshal(post)
						// Helper map to preserve "type": "post"
						var postMap map[string]interface{}
						json.Unmarshal(updatedBytes, &postMap)
						postMap["type"] = "post"
						finalBytes, _ := json.Marshal(postMap)

						if _, err := container.UpsertItem(ctx, pk, finalBytes, nil); err != nil {
							fmt.Printf("Error updating post %s: %v\n", post.ID, err)
						} else {
							fmt.Printf("Successfully updated nickname in post %s\n", post.ID)
						}
					}
				}
			}
		}

		// Query 2: Commenter (and not Author, to avoid double write, though double write is safe but wasteful)
		// SELECT * FROM c WHERE ARRAY_CONTAINS(c.comments, {'userId': @uid}, true) AND c.authorId != @uid
		pagerComments := container.NewQueryItemsPager("SELECT * FROM c WHERE ARRAY_CONTAINS(c.comments, {'userId': @uid}, true) AND c.authorId != @uid", pk, queryOpts)
		for pagerComments.More() {
			resp, err := pagerComments.NextPage(ctx)
			if err != nil {
				break
			}
			for _, bytes := range resp.Items {
				var post model.Post
				if err := json.Unmarshal(bytes, &post); err == nil {
					updated := false
					for _, c := range post.Comments {
						if c.UserID == uuid && c.UserNickname != nickname {
							c.UserNickname = nickname
							updated = true
						}
					}

					if updated {
						updatedBytes, _ := json.Marshal(post)
						var postMap map[string]interface{}
						json.Unmarshal(updatedBytes, &postMap)
						postMap["type"] = "post"
						finalBytes, _ := json.Marshal(postMap)
						if _, err := container.UpsertItem(ctx, pk, finalBytes, nil); err != nil {
							fmt.Printf("Error updating post comment %s: %v\n", post.ID, err)
						} else {
							fmt.Printf("Successfully updated nickname in post comment %s\n", post.ID)
						}
					}
				}
			}
		}
	} else {
		fmt.Printf("Error getting social container: %v\n", err)
	}

	return r.FetchUser(ctx, uuid)
}

// AddInventoryItem is the resolver for the addInventoryItem field.
func (r *mutationResolver) AddInventoryItem(ctx context.Context, input model.AddInventoryItemInput) (*model.InventoryItem, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	fridge, err := r.FetchFridge(ctx, uid)
	if err != nil {
		return nil, err
	}

	now := time.Now()
	newItem := &model.InventoryItem{
		ID:               "User@" + uuid.New().String(),
		Name:             input.Name,
		Brand:            input.Brand,
		Category:         input.Category,
		Quantity:         &model.Quantity{Value: input.Quantity.Value, Unit: input.Quantity.Unit},
		VirtualAvailable: input.Quantity.Value,
		Price:            input.Price,
		Status:           model.ItemStatusAvailable,
		ExpiryDate:       input.ExpiryDate, // Assuming DateTime scalar is string compat
		ExpiryType:       input.ExpiryType,
		AddedAt:          now.Format(time.RFC3339),
		ActiveLocks:      []*model.ProductLock{},
	}
	if input.Status != nil {
		newItem.Status = *input.Status
	}

	fridge.Items = append(fridge.Items, newItem)

	if err := r.UpsertFridge(ctx, fridge); err != nil {
		return nil, err
	}

	return newItem, nil
}

// UpdateInventoryItem is the resolver for the updateInventoryItem field.
func (r *mutationResolver) UpdateInventoryItem(ctx context.Context, id string, input model.UpdateInventoryItemInput) (*model.InventoryItem, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	fridge, err := r.FetchFridge(ctx, uid)
	if err != nil {
		return nil, err
	}

	var item *model.InventoryItem
	for _, i := range fridge.Items {
		if i.ID == id {
			item = i
			break
		}
	}
	if item == nil {
		return nil, fmt.Errorf(logic.ErrItemNotFound)
	}

	if input.Name != nil {
		item.Name = *input.Name
	}
	if input.Brand != nil {
		item.Brand = input.Brand
	}
	if input.Category != nil {
		item.Category = input.Category
	}
	if input.Price != nil {
		item.Price = input.Price
	}
	if input.Status != nil {
		item.Status = *input.Status
	}
	if input.Quantity != nil {
		item.Quantity = &model.Quantity{Value: input.Quantity.Value, Unit: input.Quantity.Unit}

		// Recalculate virtual available based on new quantity
		item.VirtualAvailable = item.Quantity.Value
		var activeLocksTotal float64 = 0
		for _, l := range item.ActiveLocks {
			activeLocksTotal += l.Amount
		}
		item.VirtualAvailable -= activeLocksTotal

		// Validation: check if new quantity is less than locked amount
		if item.VirtualAvailable < -0.001 {
			return nil, fmt.Errorf("cannot reduce quantity below locked amount (%f)", activeLocksTotal)
		}
	}
	if input.ExpiryDate != nil {
		item.ExpiryDate = *input.ExpiryDate
	}
	if input.ExpiryType != nil {
		item.ExpiryType = *input.ExpiryType
	}

	if err := r.UpsertFridge(ctx, fridge); err != nil {
		return nil, err
	}

	return item, nil
}

// DeleteInventoryItem is the resolver for the deleteInventoryItem field.
func (r *mutationResolver) DeleteInventoryItem(ctx context.Context, id string) (bool, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return false, err
	}

	fridge, err := r.FetchFridge(ctx, uid)
	if err != nil {
		return false, err
	}

	newItems := []*model.InventoryItem{}
	found := false
	for _, i := range fridge.Items {
		if i.ID == id {
			if len(i.ActiveLocks) > 0 {
				return false, fmt.Errorf("cannot delete item %s because it is used in active recipes", i.Name)
			}
			found = true
			continue
		}
		newItems = append(newItems, i)
	}

	if !found {
		return false, nil
	}

	fridge.Items = newItems
	if err := r.UpsertFridge(ctx, fridge); err != nil {
		return false, err
	}

	return true, nil
}

// ConsumeInventoryItem is the resolver for the consumeInventoryItem field.
func (r *mutationResolver) ConsumeInventoryItem(ctx context.Context, id string, amount float64) (*model.InventoryItem, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	fridge, err := r.FetchFridge(ctx, uid)
	if err != nil {
		return nil, err
	}

	var item *model.InventoryItem
	var itemIndex int
	for i, it := range fridge.Items {
		if it.ID == id {
			item = it
			itemIndex = i
			break
		}
	}
	if item == nil {
		return nil, fmt.Errorf(logic.ErrItemNotFound)
	}

	newVal := item.Quantity.Value - amount
	if newVal < 0 {
		return nil, fmt.Errorf("insufficient quantity")
	}
	item.Quantity.Value = newVal
	item.VirtualAvailable = newVal

	if newVal == 0 {
		if len(item.ActiveLocks) > 0 {
			return nil, fmt.Errorf("cannot consume item %s completely because it is used in active recipes", item.Name)
		}
		fridge.Items = append(fridge.Items[:itemIndex], fridge.Items[itemIndex+1:]...)
	}

	if err := r.UpsertFridge(ctx, fridge); err != nil {
		return nil, err
	}

	return item, nil
}

// WasteInventoryItem is the resolver for the wasteInventoryItem field.
func (r *mutationResolver) WasteInventoryItem(ctx context.Context, id string, amount float64, reason *string) (*model.InventoryItem, error) {
	return r.ConsumeInventoryItem(ctx, id, amount)
}

// CreateRecipe is the resolver for the createRecipe field.
func (r *mutationResolver) CreateRecipe(ctx context.Context, input model.CreateRecipeInput) (*model.Recipe, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	ingredients := []*model.RecipeIngredient{}
	for _, i := range input.Ingredients {
		ingredients = append(ingredients, &model.RecipeIngredient{
			Name:                i.Name,
			Quantity:            i.Quantity,
			Unit:                i.Unit,
			InventoryItemID:     i.InventoryItemID,
			IsAvailableInFridge: false, // Calculated on read usually
		})
	}

	steps := []string{}
	if input.Steps != nil {
		steps = input.Steps
	}

	desc := ""
	if input.Description != nil {
		desc = *input.Description
	}

	newRecipe := &model.Recipe{
		ID:              uuid.New().String(),
		AuthorID:        uid,
		Title:           input.Title,
		Description:     desc,
		Status:          model.RecipeStatusProposed,
		Ingredients:     ingredients,
		Steps:           steps,
		PrepTimeMinutes: input.PrepTimeMinutes,
		Calories:        input.Calories,
		EcoPointsReward: input.EcoPointsReward,
		GeneratedByAi:   false,
	}

	newRecipe.Status = model.RecipeStatusProposed

	if err := r.UpsertRecipe(ctx, newRecipe); err != nil {
		return nil, err
	}

	return newRecipe, nil
}

// UpdateRecipe is the resolver for the updateRecipe field.
func (r *mutationResolver) UpdateRecipe(ctx context.Context, id string, input model.UpdateRecipeInput) (*model.Recipe, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	recipe, err := r.FetchRecipe(ctx, id)
	if err != nil {
		return nil, err
	}

	if recipe.AuthorID != uid {
		return nil, fmt.Errorf("unauthorized")
	}

	if recipe.Status == model.RecipeStatusCooked {
		return nil, fmt.Errorf("cannot modify a cooked recipe")
	}

	if recipe.GeneratedByAi {
		return nil, fmt.Errorf("cannot modify AI generated recipe")
	}

	if input.Title != nil {
		recipe.Title = *input.Title
	}
	if input.Description != nil {
		recipe.Description = *input.Description
	}
	ingredientsChanged := false
	if input.Ingredients != nil {
		ingredients := []*model.RecipeIngredient{}
		for _, i := range input.Ingredients {
			ingredients = append(ingredients, &model.RecipeIngredient{
				Name:            i.Name,
				Quantity:        i.Quantity,
				Unit:            i.Unit,
				InventoryItemID: i.InventoryItemID,
			})
		}
		recipe.Ingredients = ingredients
		ingredientsChanged = true
	}
	if input.Steps != nil {
		recipe.Steps = input.Steps
	}
	if input.PrepTimeMinutes != nil {
		recipe.PrepTimeMinutes = input.PrepTimeMinutes
	}
	if input.Calories != nil {
		recipe.Calories = input.Calories
	}

	// Status Transition Logic
	if input.Status != nil {
		oldStatus := recipe.Status
		newStatus := *input.Status

		if newStatus != oldStatus {
			// 1. Proposed -> InPreparation (Lock)
			if oldStatus == model.RecipeStatusProposed && newStatus == model.RecipeStatusInPreparation {
				if err := r.LockIngredients(ctx, uid, recipe); err != nil {
					return nil, err
				}
			}

			// 2. InPreparation -> Proposed OR Saved (Unlock)
			if oldStatus == model.RecipeStatusInPreparation && (newStatus == model.RecipeStatusProposed || newStatus == model.RecipeStatusSaved) {
				if err := r.UnlockIngredients(ctx, uid, recipe.ID); err != nil {
					return nil, err
				}
			}

			// 3. Any -> Cooked (Handle Consumption)
			// If it was InPreparation, we need to unlock first to release reservations
			if oldStatus == model.RecipeStatusInPreparation && newStatus == model.RecipeStatusCooked {
				if err := r.UnlockIngredients(ctx, uid, recipe.ID); err != nil {
					return nil, err
				}
			}
			// Now consume the actual quantity (for cooked)
			if newStatus == model.RecipeStatusCooked {
				if err := r.ApplyCooking(ctx, uid, recipe); err != nil {
					return nil, err
				}

				// Gamification logic...
				points := int32(0)
				if recipe.EcoPointsReward != nil {
					points = *recipe.EcoPointsReward
				}

				if points > 0 {
					user, err := r.FetchUser(ctx, uid)
					if err != nil {
						return nil, err
					}

					if user.Gamification == nil {
						user.Gamification = &model.GamificationProfile{
							CurrentLevel:       1,
							NextLevelThreshold: 100,
						}
					}

					user.Gamification.TotalEcoPoints += points
					r.EvaluateLevelUp(user)

					if err := r.UpsertUser(ctx, user); err != nil {
						return nil, err
					}

					r.UpsertLeaderboardEntry(ctx, user)
					r.SetUserCache(ctx, user)
				}
			}
		}
		recipe.Status = *input.Status
	} else if ingredientsChanged && recipe.Status == model.RecipeStatusInPreparation {
		// If status didn't change but ingredients did, and we are InPreparation, re-lock
		if err := r.UnlockIngredients(ctx, uid, recipe.ID); err != nil {
			return nil, err
		}
		if err := r.LockIngredients(ctx, uid, recipe); err != nil {
			return nil, err
		}
	}

	if err := r.UpsertRecipe(ctx, recipe); err != nil {
		return nil, err
	}

	return recipe, nil
}

// DeleteRecipe is the resolver for the deleteRecipe field.
func (r *mutationResolver) DeleteRecipe(ctx context.Context, id string) (bool, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return false, err
	}

	// Just check if it exists and author matches
	recipe, err := r.FetchRecipe(ctx, id)
	if err != nil {
		return false, err
	}

	if recipe.AuthorID != uid {
		return false, fmt.Errorf("unauthorized")
	}

	// Only unlock if the recipe was NOT cooked.
	// If it is cooked, the ingredients are consumed and should not be restored.
	if recipe.Status != model.RecipeStatusCooked {
		if err := r.UnlockIngredients(ctx, uid, recipe.ID); err != nil {
			return false, err
		}
	}

	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerCookbook)
	if err != nil {
		return false, err
	}

	// Delete needs PK which is AuthorID
	_, err = container.DeleteItem(ctx, azcosmos.NewPartitionKeyString(recipe.AuthorID), id, nil)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CookRecipe is the resolver for the cookRecipe field.
func (r *mutationResolver) CookRecipe(ctx context.Context, id string) (*model.Recipe, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	recipe, err := r.FetchRecipe(ctx, id)
	if err != nil {
		return nil, err
	}

	if recipe.AuthorID != uid {
		return nil, fmt.Errorf("unauthorized")
	}

	if recipe.Status == model.RecipeStatusCooked {
		return recipe, nil
	}

	// Always unlock first to release any existing reservations (if it was InPreparation)
	if err := r.UnlockIngredients(ctx, uid, recipe.ID); err != nil {
		return nil, err
	}

	if err := r.ApplyCooking(ctx, uid, recipe); err != nil {
		return nil, err
	}

	recipe.Status = model.RecipeStatusCooked
	if err := r.UpsertRecipe(ctx, recipe); err != nil {
		return nil, err
	}

	return recipe, nil
}

// SaveRecipe is the resolver for the saveRecipe field.
func (r *mutationResolver) SaveRecipe(ctx context.Context, id string) (*model.Recipe, error) {
	panic(fmt.Errorf("not implemented: SaveRecipe - saveRecipe"))
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.CreatePostInput) (*model.Post, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	// Verify recipe exists
	recipe, err := r.FetchRecipe(ctx, input.RecipeID)
	if err != nil {
		return nil, fmt.Errorf("recipe not found")
	}

	// Get Author details
	author, err := r.FetchUser(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("user not found")
	}

	// Create Snapshot
	ings := []*model.RecipeIngredientSnapshot{}
	for _, i := range recipe.Ingredients {
		ings = append(ings, &model.RecipeIngredientSnapshot{
			Name:     i.Name,
			Quantity: i.Quantity,
			Unit:     i.Unit,
		})
	}

	desc := recipe.Description
	snapshot := &model.RecipeSnapshot{
		Title:           recipe.Title,
		Description:     &desc,
		Ingredients:     ings,
		Steps:           recipe.Steps,
		PrepTimeMinutes: recipe.PrepTimeMinutes,
		Calories:        recipe.Calories,
		EcoPointsReward: recipe.EcoPointsReward,
	}

	postID := uuid.New().String()
	now := time.Now().Format(time.RFC3339)

	imgURL := ""
	if input.ImageURL != nil && *input.ImageURL != "" {
		// Expecting clean URL (no SAS). We need to extract the blob name.
		// URL format: https://<account>.blob.core.windows.net/social/pending/<uuid>.jpg
		u, err := url.Parse(*input.ImageURL)
		if err != nil {
			return nil, fmt.Errorf("invalid image url")
		}

		// Path should contain "/social/users/<uid>/pending/" OR just "/social/pending/" (backward compatibility)
		// Actually, let's just look for "pending/" as a marker.
		if !strings.Contains(u.Path, "/pending/") {
			return nil, fmt.Errorf("image must be uploaded via the app")
		}

		// Extract blob name: "users/<uid>/pending/<filename>"
		parts := strings.Split(u.Path, "/social/")
		if len(parts) < 2 {
			return nil, fmt.Errorf("invalid blob path")
		}
		srcBlobName := parts[1] // "users/uid/pending/..."

		destBlobName := "posts/" + postID + ".jpg"
		// Extract extension from srcBlobName if possible
		if dot := strings.LastIndex(srcBlobName, "."); dot != -1 {
			destBlobName = "posts/" + postID + srcBlobName[dot:]
		}

		// Move Blob
		finalURL, err := r.RelocateBlob(ctx, "social", srcBlobName, destBlobName)
		if err != nil {
			return nil, fmt.Errorf("failed to process image: %v", err)
		}
		imgURL = finalURL
	}

	newPost := &model.Post{
		ID:             postID,
		AuthorID:       uid,
		AuthorNickname: author.Nickname,
		RecipeSnapshot: snapshot,
		Caption:        input.Caption,
		ImageURL:       &imgURL,
		LikesCount:     0,
		LikedBy:        []string{},
		CreatedAt:      now,
		Comments:       []*model.Comment{},
	}

	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerSocial)
	if err != nil {
		return nil, err
	}

	// Use map to include "type" field for partition key logic

	postMap := map[string]interface{}{}
	b, _ := json.Marshal(newPost)
	json.Unmarshal(b, &postMap)
	postMap["type"] = "post"

	data, err := json.Marshal(postMap)
	if err != nil {
		return nil, err
	}

	_, err = container.UpsertItem(ctx, azcosmos.NewPartitionKeyString("post"), data, nil)
	if err != nil {
		return nil, err
	}

	// Award points
	if author.Gamification == nil {
		// Load user again? We have author.
		author.Gamification = &model.GamificationProfile{TotalEcoPoints: 0, CurrentLevel: 1, NextLevelThreshold: 100}
	}
	author.Gamification.TotalEcoPoints += 10
	if err := r.UpsertUser(ctx, author); err == nil {
		r.UpsertLeaderboardEntry(ctx, author)
		r.SetUserCache(ctx, author)
	}

	return newPost, nil
}

// UpdatePost is the resolver for the updatePost field.
func (r *mutationResolver) UpdatePost(ctx context.Context, id string, caption string) (*model.Post, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerSocial)
	if err != nil {
		return nil, err
	}

	// Read Post
	var post model.Post
	resp, err := container.ReadItem(ctx, azcosmos.NewPartitionKeyString("post"), id, nil)
	if err != nil {
		return nil, err
	}
	if err := json.Unmarshal(resp.Value, &post); err != nil {
		return nil, err
	}

	// Check Authorization
	if post.AuthorID != uid {
		return nil, fmt.Errorf("unauthorized")
	}

	// Update logic
	post.Caption = &caption

	// Save back (preserving "type"="post")
	postMap := map[string]interface{}{}
	b, _ := json.Marshal(post)
	json.Unmarshal(b, &postMap)
	postMap["type"] = "post"

	finalData, _ := json.Marshal(postMap)
	_, err = container.UpsertItem(ctx, azcosmos.NewPartitionKeyString("post"), finalData, nil)
	if err != nil {
		return nil, err
	}

	return &post, nil
}

// DeletePost is the resolver for the deletePost field.
func (r *mutationResolver) DeletePost(ctx context.Context, id string) (bool, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return false, err
	}

	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerSocial)
	if err != nil {
		return false, err
	}

	// PK is "post"
	itemResponse, err := container.ReadItem(ctx, azcosmos.NewPartitionKeyString("post"), id, nil)
	if err != nil {
		return false, err
	}

	var postData map[string]interface{}
	if err := json.Unmarshal(itemResponse.Value, &postData); err != nil {
		return false, err
	}

	authorId, ok := postData["authorId"].(string)
	if !ok || authorId != uid {
		return false, fmt.Errorf("unauthorized")
	}

	_, err = container.DeleteItem(ctx, azcosmos.NewPartitionKeyString("post"), id, nil)
	return err == nil, err
}

// LikePost is the resolver for the likePost field.
func (r *mutationResolver) LikePost(ctx context.Context, postID string) (*model.Post, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerSocial)
	if err != nil {
		return nil, err
	}

	// Read Post
	var post model.Post // Note: this won't have "type", but that's fine for unmarshal
	resp, err := container.ReadItem(ctx, azcosmos.NewPartitionKeyString("post"), postID, nil)
	if err != nil {
		return nil, err
	}
	if err := json.Unmarshal(resp.Value, &post); err != nil {
		return nil, err
	}

	// Check if already liked
	alreadyLiked := false
	for _, id := range post.LikedBy {
		if id == uid {
			alreadyLiked = true
			break
		}
	}

	if !alreadyLiked {
		post.LikedBy = append(post.LikedBy, uid)
		post.LikesCount = int32(len(post.LikedBy))

		// Save back (preserving "type"="post")
		postMap := map[string]interface{}{}
		b, _ := json.Marshal(post)
		json.Unmarshal(b, &postMap)
		postMap["type"] = "post"

		finalData, _ := json.Marshal(postMap)
		_, err = container.UpsertItem(ctx, azcosmos.NewPartitionKeyString("post"), finalData, nil)
		if err != nil {
			return nil, err
		}
	}

	return &post, nil
}

// UnlikePost is the resolver for the unlikePost field.
func (r *mutationResolver) UnlikePost(ctx context.Context, postID string) (*model.Post, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerSocial)
	if err != nil {
		return nil, err
	}

	var post model.Post
	resp, err := container.ReadItem(ctx, azcosmos.NewPartitionKeyString("post"), postID, nil)
	if err != nil {
		return nil, err
	}
	if err := json.Unmarshal(resp.Value, &post); err != nil {
		return nil, err
	}

	newLikedBy := []string{}
	found := false
	for _, id := range post.LikedBy {
		if id == uid {
			found = true
			continue
		}
		newLikedBy = append(newLikedBy, id)
	}

	if found {
		post.LikedBy = newLikedBy
		post.LikesCount = int32(len(post.LikedBy))

		postMap := map[string]interface{}{}
		b, _ := json.Marshal(post)
		json.Unmarshal(b, &postMap)
		postMap["type"] = "post"

		finalData, _ := json.Marshal(postMap)
		_, err = container.UpsertItem(ctx, azcosmos.NewPartitionKeyString("post"), finalData, nil)
		if err != nil {
			return nil, err
		}
	}

	return &post, nil
}

// AddComment is the resolver for the addComment field.
func (r *mutationResolver) AddComment(ctx context.Context, postID string, text string) (*model.Comment, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.FetchUser(ctx, uid)
	if err != nil {
		return nil, err
	}

	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerSocial)
	if err != nil {
		return nil, err
	}

	var post model.Post
	resp, err := container.ReadItem(ctx, azcosmos.NewPartitionKeyString("post"), postID, nil)
	if err != nil {
		return nil, err
	}
	if err := json.Unmarshal(resp.Value, &post); err != nil {
		return nil, err
	}

	newComment := &model.Comment{
		ID:           uuid.New().String(),
		UserID:       uid,
		UserNickname: user.Nickname,
		Text:         text,
		CreatedAt:    time.Now().Format(time.RFC3339),
	}

	post.Comments = append(post.Comments, newComment)

	postMap := map[string]interface{}{}
	b, _ := json.Marshal(post)
	json.Unmarshal(b, &postMap)
	postMap["type"] = "post"

	finalData, _ := json.Marshal(postMap)
	_, err = container.UpsertItem(ctx, azcosmos.NewPartitionKeyString("post"), finalData, nil)
	if err != nil {
		return nil, err
	}

	return newComment, nil
}

// GenerateUploadSasToken is the resolver for the generateUploadSasToken field.
// GenerateUploadSasToken is the resolver for the generateUploadSasToken field.
func (r *mutationResolver) GenerateUploadSasToken(ctx context.Context, filename string, purpose model.UploadPurpose) (string, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return "", err
	}

	containerName := "uploads"
	prefix := ""

	switch purpose {
	case model.UploadPurposeSocialPost:
		containerName = "social"
		prefix = fmt.Sprintf("users/%s/pending", uid)
	case model.UploadPurposeRecipeGeneration:
		prefix = fmt.Sprintf("recipes-input/users/%s", uid)
		containerName = "recipes-input"
	case model.UploadPurposeReceiptScanning:
		// User requested to reuse 'uploads' container
		// Path: receipts/{userId}/{filename}
		containerName = "uploads"
		prefix = fmt.Sprintf("receipts/%s", uid)
	case model.UploadPurposeProductLabel:
		// Reuse 'uploads' container
		// Path: product-labels/{userId}/{sessionId}/{itemId}/{filename}
		// Expect filename to contain "{sessionId}/{itemId}/image.jpg"
		containerName = "uploads"
		prefix = fmt.Sprintf("product-labels/%s", uid)

		// Debug log for simulation script
		fullBlobPath := fmt.Sprintf("%s/%s", prefix, filename)
		log.Printf("[PRODUCT_LABEL_DEBUG] Uploading to: %s/%s. Use this path in simulation script.", containerName, fullBlobPath)
		if os.Getenv("STORAGE_ACCOUNT_NAME") == "" {
			// Local dev suggestion
			log.Printf("[PRODUCT_LABEL_DEBUG] Local URL: http://127.0.0.1:10000/devstoreaccount1/%s/%s", containerName, fullBlobPath)
		}
	default:
		return "", fmt.Errorf("invalid upload purpose")
	}

	// Validate filename (basic)
	if filename == "" {
		return "", fmt.Errorf("filename required")
	}

	// Ensure container exists (fixes 404 local issue)
	if err := r.CreateContainerIfNotExists(ctx, containerName); err != nil {
		fmt.Printf("Warning: Failed to ensure container exists: %v\n", err)
	}

	blobName := fmt.Sprintf("%s/%s", prefix, filename)

	// Use Logic helper which handles Dev/Prod (DefaultCredential) automatically
	perms := sas.BlobPermissions{Read: true, Create: true, Write: true}

	sasUrl, err := r.CreateSAS(ctx, containerName, blobName, perms, 1*time.Hour)
	if err == nil {
		fmt.Printf("Generated SAS URL: %s\n", sasUrl)
	}
	return sasUrl, err
}

// RegisterDevice is the resolver for the registerDevice field.
func (r *mutationResolver) RegisterDevice(ctx context.Context, handle string, platform string, installationID *string) (bool, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return false, err
	}

	funcURL := os.Getenv("AZURE_FUNCTIONS_URL")
	if funcURL == "" {
		funcURL = "http://localhost:7071/api"
	}
	registerURL := fmt.Sprintf("%s/register_device", funcURL)

	payload := map[string]interface{}{
		"handle":         handle,
		"platform":       platform,
		"userId":         uid,
		"installationId": installationID,
	}

	jsonBody, _ := json.Marshal(payload)
	req, err := http.NewRequest("POST", registerURL, bytes.NewBuffer(jsonBody))
	if err != nil {
		fmt.Printf("Failed to create request to Function: %v\n", err)
		return true, nil
	}
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{Timeout: 5 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Printf("WARNING: Notification registration failed (Function App unreachable at %s). Ignoring for local dev.\n", funcURL)
		return true, nil
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 && resp.StatusCode != 201 {
		bodyBytes, _ := io.ReadAll(resp.Body)
		fmt.Printf("WARNING: Notification registration returned error: %s\n", string(bodyBytes))
		return true, nil
	}

	return true, nil
}

// AddShoppingHistory is the resolver for the addShoppingHistory field.
func (r *mutationResolver) AddShoppingHistory(ctx context.Context, input model.AddShoppingHistoryInput) (*model.ShoppingHistoryEntry, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.FetchUser(ctx, uid)
	if err != nil {
		return nil, err
	}

	currency := "EUR"
	if input.Currency != nil {
		currency = *input.Currency
	} else if user.Preferences != nil {
		currency = user.Preferences.Currency.String()
	}

	items := []*model.HistoryItem{}
	for _, i := range input.Items {
		var itemID *string
		if i.ID != nil {
			itemID = i.ID
		} else {
			newID := uuid.New().String()
			itemID = &newID
		}
		items = append(items, &model.HistoryItem{
			ID:         itemID,
			Name:       i.Name,
			Price:      i.Price,
			Quantity:   i.Quantity,
			Category:   i.Category,
			Brand:      i.Brand,
			Unit:       i.Unit,
			ExpiryDate: i.ExpiryDate,
			ExpiryType: i.ExpiryType,
			Confidence: i.Confidence,
		})
	}

	status := model.ShoppingHistoryStatusSaved
	if input.Status != nil {
		status = *input.Status
	}

	entry := &model.ShoppingHistoryEntry{
		ID:              uuid.New().String(),
		AuthorID:        uid,
		Date:            input.Date,
		StoreName:       &input.StoreName,
		TotalAmount:     &input.TotalAmount,
		Currency:        currency,
		IsImported:      false,
		ItemsSnapshot:   items,
		ReceiptImageURL: input.ReceiptImageURL,
		Status:          status,
	}

	if err := r.UpsertShoppingHistory(ctx, entry); err != nil {
		return nil, err
	}

	return entry, nil
}

// UpdateShoppingHistory is the resolver for the updateShoppingHistory field.
func (r *mutationResolver) UpdateShoppingHistory(ctx context.Context, id string, input model.UpdateShoppingHistoryInput) (*model.ShoppingHistoryEntry, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	entry, err := r.FetchShoppingHistory(ctx, id)
	if err != nil {
		return nil, err
	}

	if entry.AuthorID != uid {
		return nil, fmt.Errorf("unauthorized")
	}

	if entry.IsImported {
		return nil, fmt.Errorf("cannot update imported history")
	}

	if input.Status != nil {
		entry.Status = *input.Status
	}

	if input.StoreName != nil {
		entry.StoreName = input.StoreName
	}
	if input.TotalAmount != nil {
		entry.TotalAmount = input.TotalAmount
	}
	if input.Date != nil {
		entry.Date = *input.Date
	}
	if input.Currency != nil {
		entry.Currency = *input.Currency
	}
	if input.ReceiptImageURL != nil {
		entry.ReceiptImageURL = input.ReceiptImageURL
	}
	if input.Items != nil {
		items := []*model.HistoryItem{}
		for _, i := range input.Items {
			var itemID *string
			if i.ID != nil {
				itemID = i.ID
			} else {
				newID := uuid.New().String()
				itemID = &newID
			}
			items = append(items, &model.HistoryItem{
				ID:         itemID,
				Name:       i.Name,
				Price:      i.Price,
				Quantity:   i.Quantity,
				Category:   i.Category,
				Brand:      i.Brand,
				Unit:       i.Unit,
				ExpiryDate: i.ExpiryDate,
				ExpiryType: i.ExpiryType,
				Confidence: i.Confidence,
			})
		}
		entry.ItemsSnapshot = items
	}

	if err := r.UpsertShoppingHistory(ctx, entry); err != nil {
		return nil, err
	}

	return entry, nil
}

// DeleteShoppingHistory is the resolver for the deleteShoppingHistory field.
func (r *mutationResolver) DeleteShoppingHistory(ctx context.Context, id string) (bool, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return false, err
	}

	entry, err := r.FetchShoppingHistory(ctx, id)
	if err != nil {
		return false, err
	}

	if entry.AuthorID != uid {
		return false, fmt.Errorf("unauthorized")
	}

	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerHistory)
	if err != nil {
		return false, err
	}

	_, err = container.DeleteItem(ctx, azcosmos.NewPartitionKeyString(uid), id, nil)
	if err != nil {
		return false, err
	}

	return true, nil
}

// ImportShoppingHistoryToFridge is the resolver for the importShoppingHistoryToFridge field.
func (r *mutationResolver) ImportShoppingHistoryToFridge(ctx context.Context, id string) (*model.ShoppingHistoryEntry, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	entry, err := r.FetchShoppingHistory(ctx, id)
	if err != nil {
		return nil, err
	}

	if entry.AuthorID != uid {
		return nil, fmt.Errorf("unauthorized")
	}

	if entry.IsImported {
		return nil, fmt.Errorf("history already imported")
	}

	fridge, err := r.FetchFridge(ctx, uid)
	if err != nil {
		return nil, err
	}

	now := time.Now()
	for _, histItem := range entry.ItemsSnapshot {
		price := float64(0)
		if histItem.Price != nil {
			price = *histItem.Price
		}

		var qtyVal float64 = 1.0
		if histItem.Quantity != nil {
			qtyVal = *histItem.Quantity
		}

		var unitVal model.Unit = model.UnitPz
		if histItem.Unit != nil {
			unitVal = *histItem.Unit
		}

		newItem := &model.InventoryItem{
			ID:               "User@" + uuid.New().String(),
			Name:             histItem.Name,
			Quantity:         &model.Quantity{Value: qtyVal, Unit: unitVal},
			VirtualAvailable: qtyVal,
			Price:            &price,
			Status:           model.ItemStatusAvailable,
			AddedAt:          now.Format(time.RFC3339),
			ActiveLocks:      []*model.ProductLock{},
		}

		if histItem.ExpiryDate != nil {
			newItem.ExpiryDate = *histItem.ExpiryDate
		} else {
			newItem.ExpiryDate = now.Add(7 * 24 * time.Hour).Format(time.RFC3339)
		}

		if histItem.ExpiryType != nil {
			newItem.ExpiryType = *histItem.ExpiryType
		} else {
			newItem.ExpiryType = model.ExpiryTypeBestBefore
		}

		if histItem.Category != nil {
			newItem.Category = histItem.Category
		}
		if histItem.Brand != nil {
			newItem.Brand = histItem.Brand
		}

		fridge.Items = append(fridge.Items, newItem)
	}

	if err := r.UpsertFridge(ctx, fridge); err != nil {
		return nil, err
	}

	entry.IsImported = true
	if err := r.UpsertShoppingHistory(ctx, entry); err != nil {
		fmt.Printf("Error marking history as imported: %v\n", err)
		return nil, err
	}

	return entry, nil
}

// GenerateSharedFridgeLink is the resolver for the generateSharedFridgeLink field.
func (r *mutationResolver) GenerateSharedFridgeLink(ctx context.Context) (*model.SharedFridgeLink, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	usId, err := r.Redis.Get(ctx, "invite:user:"+uid).Result()
	if err == nil && usId != "" {
		return &model.SharedFridgeLink{
			AuthorID:   uid,
			InviteCode: usId,
		}, nil
	}

	// Create new invite

	share := &model.SharedFridgeLink{
		AuthorID:   uid,
		InviteCode: uuid.New().String(),
	}

	r.Redis.Set(ctx, "invite:code:"+share.InviteCode, uid, time.Minute*60)
	r.Redis.Set(ctx, "invite:user:"+uid, share.InviteCode, time.Minute*60)

	return share, nil
}

// AddFridgeShared is the resolver for the addFridgeShared field.
func (r *mutationResolver) AddFridgeShared(ctx context.Context, sharedID *string) (*string, error) {
	userId, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	uid, err := r.Redis.Get(ctx, "invite:code:"+*sharedID).Result()
	if err != nil {
		return nil, err
	}

	if uid == userId {
		return nil, fmt.Errorf("cannot share fridge with yourself")
	}

	// Avoid PatchItem due to marshalling issues with arrays
	targetFridge, err := r.FetchFridge(ctx, uid)
	if err != nil {
		return nil, err
	}

	alreadyOwner := false
	for _, owner := range targetFridge.OwnerID {
		if owner == userId {
			alreadyOwner = true
			break
		}
	}

	if !alreadyOwner {
		targetFridge.OwnerID = append(targetFridge.OwnerID, userId)
		if err := r.UpsertFridge(ctx, targetFridge); err != nil {
			return nil, err
		}
	}
	return &userId, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	return r.FetchUser(ctx, uid)
}

// MyFridge is the resolver for the myFridge field.
func (r *queryResolver) MyFridge(ctx context.Context) ([]*model.Fridge, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}
	return r.Logic.FetchFridges(ctx, uid)
}

// ShoppingHistory is the resolver for the shoppingHistory field.
func (r *queryResolver) ShoppingHistory(ctx context.Context, limit *int32, offset *int32) ([]*model.ShoppingHistoryEntry, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	l := 10
	if limit != nil {
		l = int(*limit)
	}
	o := 0
	if offset != nil {
		o = int(*offset)
	}

	entries, err := r.FetchShoppingHistoryList(ctx, uid, l, o)
	if err != nil {
		return nil, err
	}

	// Sign receiptImageUrl for each entry
	for _, entry := range entries {
		if entry.ReceiptImageURL != nil && *entry.ReceiptImageURL != "" {
			signedURL, signErr := r.signReceiptURL(ctx, *entry.ReceiptImageURL)
			if signErr == nil {
				entry.ReceiptImageURL = &signedURL
			}
		}
	}

	return entries, nil
}

// ShoppingHistoryEntry is the resolver for the shoppingHistoryEntry field.
func (r *queryResolver) ShoppingHistoryEntry(ctx context.Context, id string) (*model.ShoppingHistoryEntry, error) {
	return r.FetchShoppingHistory(ctx, id)
}

// MyRecipes is the resolver for the myRecipes field.
func (r *queryResolver) MyRecipes(ctx context.Context, status *model.RecipeStatus) ([]*model.Recipe, error) {
	uid, err := r.ResolveUserID(ctx)
	if err != nil {
		return nil, err
	}

	query := "SELECT * FROM c WHERE c.authorId = @uid"
	if status != nil {
		query += fmt.Sprintf(" AND c.status = '%s'", *status)
	}

	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerCookbook)
	if err != nil {
		return nil, err
	}

	qOpts := azcosmos.QueryOptions{
		QueryParameters: []azcosmos.QueryParameter{
			{Name: "@uid", Value: uid},
		},
	}

	// Use PK = AuthorID = uid
	pager := container.NewQueryItemsPager(query, azcosmos.NewPartitionKeyString(uid), &qOpts)

	var recipes []*model.Recipe
	for pager.More() {
		resp, err := pager.NextPage(ctx)
		if err != nil {
			return nil, err
		}
		for _, bytes := range resp.Items {
			var recipe model.Recipe
			if err := json.Unmarshal(bytes, &recipe); err == nil {
				recipes = append(recipes, &recipe)
			}
		}
	}
	return recipes, nil
}

// Recipe is the resolver for the recipe field.
func (r *queryResolver) Recipe(ctx context.Context, id string) (*model.Recipe, error) {
	return r.FetchRecipe(ctx, id)
}

// Feed is the resolver for the feed field.
func (r *queryResolver) Feed(ctx context.Context, limit *int32, offset *int32) ([]*model.Post, error) {
	// Cross-partition query on PK /type = 'post'
	container, err := r.Cosmos.NewContainer(logic.CosmosDatabase, logic.ContainerSocial)
	if err != nil {
		return nil, err
	}

	query := "SELECT * FROM c WHERE c.type = 'post' ORDER BY c.createdAt DESC"

	qOpts := azcosmos.QueryOptions{}

	// Use PK = 'post'
	pager := container.NewQueryItemsPager(query, azcosmos.NewPartitionKeyString("post"), &qOpts)

	var posts []*model.Post
	for pager.More() {
		resp, err := pager.NextPage(ctx)
		if err != nil {
			return nil, err
		}
		for _, bytes := range resp.Items {
			var post model.Post
			if err := json.Unmarshal(bytes, &post); err == nil {
				posts = append(posts, &post)
			}
		}
		if limit != nil && len(posts) >= int(100) { // Safety break
			break
		}
	}

	start := 0
	if offset != nil {
		start = int(*offset)
	}
	end := len(posts)
	if limit != nil {
		l := int(*limit)
		if start+l < end {
			end = start + l
		}
	} else {
		if start+20 < end {
			end = start + 20
		}
	}

	if start > len(posts) {
		return []*model.Post{}, nil
	}
	if end > len(posts) {
		end = len(posts)
	}
	if start > end {
		return []*model.Post{}, nil
	}

	return posts[start:end], nil
}

// Leaderboard is the resolver for the leaderboard field.
func (r *queryResolver) Leaderboard(ctx context.Context, top *int32) ([]*model.LeaderboardEntry, error) {
	limit := 5
	if top != nil {
		limit = int(*top)
	}
	return r.FetchLeaderboard(ctx, limit)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
