// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
)

type AddInventoryItemInput struct {
	Name       string         `json:"name"`
	Brand      *string        `json:"brand,omitempty"`
	Category   *string        `json:"category,omitempty"`
	Quantity   *QuantityInput `json:"quantity"`
	Price      *float64       `json:"price,omitempty"`
	Status     *ItemStatus    `json:"status,omitempty"`
	ExpiryDate string         `json:"expiryDate"`
	ExpiryType ExpiryType     `json:"expiryType"`
}

type Comment struct {
	ID           string `json:"id"`
	UserID       string `json:"userId"`
	UserNickname string `json:"userNickname"`
	Text         string `json:"text"`
	CreatedAt    string `json:"createdAt"`
}

type CreatePostInput struct {
	RecipeID string  `json:"recipeId"`
	Caption  *string `json:"caption,omitempty"`
	ImageURL *string `json:"imageUrl,omitempty"`
}

type CreateRecipeInput struct {
	Title           string                   `json:"title"`
	Description     *string                  `json:"description,omitempty"`
	Ingredients     []*RecipeIngredientInput `json:"ingredients"`
	Steps           []string                 `json:"steps"`
	PrepTimeMinutes *int32                   `json:"prepTimeMinutes,omitempty"`
	Calories        *int32                   `json:"calories,omitempty"`
	EcoPointsReward *int32                   `json:"ecoPointsReward,omitempty"`
}

type Fridge struct {
	ID      string           `json:"id"`
	Name    string           `json:"name"`
	OwnerID []string         `json:"ownerId,omitempty"`
	Items   []*InventoryItem `json:"items,omitempty"`
}

type GamificationProfile struct {
	TotalEcoPoints     int32    `json:"totalEcoPoints"`
	CurrentLevel       int32    `json:"currentLevel"`
	NextLevelThreshold int32    `json:"nextLevelThreshold"`
	Badges             []string `json:"badges,omitempty"`
	WastedMoneyYtd     *float64 `json:"wastedMoneyYTD,omitempty"`
}

type HistoryItem struct {
	Name     string  `json:"name"`
	Price    float64 `json:"price"`
	Quantity int32   `json:"quantity"`
	Category *string `json:"category,omitempty"`
}

type InventoryItem struct {
	ID               string         `json:"id"`
	Name             string         `json:"name"`
	Brand            *string        `json:"brand,omitempty"`
	Category         *string        `json:"category,omitempty"`
	Quantity         *Quantity      `json:"quantity"`
	Price            *float64       `json:"price,omitempty"`
	Status           ItemStatus     `json:"status"`
	VirtualAvailable float64        `json:"virtualAvailable"`
	ExpiryDate       string         `json:"expiryDate"`
	ExpiryType       ExpiryType     `json:"expiryType"`
	AddedAt          string         `json:"addedAt"`
	ActiveLocks      []*ProductLock `json:"activeLocks,omitempty"`
}

type LeaderboardEntry struct {
	Rank     int32  `json:"rank"`
	Nickname string `json:"nickname"`
	Score    int32  `json:"score"`
}

type Mutation struct {
}

type Post struct {
	ID             string          `json:"id"`
	AuthorID       string          `json:"authorId"`
	AuthorNickname string          `json:"authorNickname"`
	CreatedAt      string          `json:"createdAt"`
	ImageURL       *string         `json:"imageUrl,omitempty"`
	Caption        *string         `json:"caption,omitempty"`
	LikedBy        []string        `json:"likedBy"`
	LikesCount     int32           `json:"likesCount"`
	RecipeSnapshot *RecipeSnapshot `json:"recipeSnapshot"`
	Comments       []*Comment      `json:"comments"`
}

type ProductLock struct {
	RecipeID  string  `json:"recipeId"`
	Amount    float64 `json:"amount"`
	StartedAt string  `json:"startedAt"`
}

type Quantity struct {
	Value float64 `json:"value"`
	Unit  Unit    `json:"unit"`
}

type QuantityInput struct {
	Value float64 `json:"value"`
	Unit  Unit    `json:"unit"`
}

type Query struct {
}

type Recipe struct {
	ID                  string              `json:"id"`
	AuthorID            string              `json:"authorId"`
	Title               string              `json:"title"`
	Description         string              `json:"description"`
	Status              RecipeStatus        `json:"status"`
	Ingredients         []*RecipeIngredient `json:"ingredients,omitempty"`
	CookedItems         []*RecipeCookedItem `json:"cookedItems,omitempty"`
	Steps               []string            `json:"steps,omitempty"`
	PrepTimeMinutes     *int32              `json:"prepTimeMinutes,omitempty"`
	Calories            *int32              `json:"calories,omitempty"`
	EcoPointsReward     *int32              `json:"ecoPointsReward,omitempty"`
	TTLSecondsRemaining *int32              `json:"ttlSecondsRemaining,omitempty"`
	GeneratedByAi       bool                `json:"generatedByAI"`
}

type RecipeCookedItem struct {
	ID                  string    `json:"id"`
	Name                string    `json:"name"`
	Brand               *string   `json:"brand,omitempty"`
	Category            *string   `json:"category,omitempty"`
	Quantity            *Quantity `json:"quantity"`
	Price               *float64  `json:"price,omitempty"`
	UsedQuantity        float64   `json:"usedQuantity"`
	OriginalInventoryID *string   `json:"originalInventoryId,omitempty"`
}

type RecipeIngredient struct {
	Name                string         `json:"name"`
	Quantity            float64        `json:"quantity"`
	Unit                Unit           `json:"unit"`
	InventoryItem       *InventoryItem `json:"inventoryItem,omitempty"`
	InventoryItemID     *string        `json:"inventoryItemId,omitempty"`
	IsAvailableInFridge bool           `json:"isAvailableInFridge"`
}

type RecipeIngredientInput struct {
	Name            string  `json:"name"`
	Quantity        float64 `json:"quantity"`
	Unit            Unit    `json:"unit"`
	InventoryItemID *string `json:"inventoryItemId,omitempty"`
}

type RecipeIngredientSnapshot struct {
	Name     string  `json:"name"`
	Quantity float64 `json:"quantity"`
	Unit     Unit    `json:"unit"`
}

type RecipeSnapshot struct {
	Title           string                      `json:"title"`
	Description     *string                     `json:"description,omitempty"`
	Ingredients     []*RecipeIngredientSnapshot `json:"ingredients"`
	Steps           []string                    `json:"steps"`
	PrepTimeMinutes *int32                      `json:"prepTimeMinutes,omitempty"`
	Calories        *int32                      `json:"calories,omitempty"`
	EcoPointsReward *int32                      `json:"ecoPointsReward,omitempty"`
}

type ShoppingHistoryEntry struct {
	ID              string         `json:"id"`
	Date            string         `json:"date"`
	StoreName       string         `json:"storeName"`
	TotalAmount     float64        `json:"totalAmount"`
	Currency        string         `json:"currency"`
	ReceiptImageURL *string        `json:"receiptImageUrl,omitempty"`
	ItemsSnapshot   []*HistoryItem `json:"itemsSnapshot"`
}

type StagingItem struct {
	ID            string   `json:"id"`
	Name          string   `json:"name"`
	DetectedPrice *float64 `json:"detectedPrice,omitempty"`
	Quantity      *int32   `json:"quantity,omitempty"`
	Confidence    *float64 `json:"confidence,omitempty"`
}

type StagingItemInput struct {
	Name          *string  `json:"name,omitempty"`
	DetectedPrice *float64 `json:"detectedPrice,omitempty"`
	Quantity      *int32   `json:"quantity,omitempty"`
}

type StagingSession struct {
	ID            string         `json:"id"`
	DetectedStore *string        `json:"detectedStore,omitempty"`
	DetectedTotal *float64       `json:"detectedTotal,omitempty"`
	Items         []*StagingItem `json:"items,omitempty"`
	CreatedAt     string         `json:"createdAt"`
	ExpiresAt     string         `json:"expiresAt"`
}

type UpdateInventoryItemInput struct {
	Name       *string        `json:"name,omitempty"`
	Brand      *string        `json:"brand,omitempty"`
	Category   *string        `json:"category,omitempty"`
	Quantity   *QuantityInput `json:"quantity,omitempty"`
	Price      *float64       `json:"price,omitempty"`
	Status     *ItemStatus    `json:"status,omitempty"`
	ExpiryDate *string        `json:"expiryDate,omitempty"`
	ExpiryType *ExpiryType    `json:"expiryType,omitempty"`
}

type UpdateRecipeInput struct {
	Title           *string                  `json:"title,omitempty"`
	Description     *string                  `json:"description,omitempty"`
	Status          *RecipeStatus            `json:"status,omitempty"`
	Ingredients     []*RecipeIngredientInput `json:"ingredients,omitempty"`
	Steps           []string                 `json:"steps,omitempty"`
	PrepTimeMinutes *int32                   `json:"prepTimeMinutes,omitempty"`
	Calories        *int32                   `json:"calories,omitempty"`
}

type User struct {
	ID           string               `json:"id"`
	Email        string               `json:"email"`
	Nickname     string               `json:"nickname"`
	AvatarURL    *string              `json:"avatarUrl,omitempty"`
	Origin       AccountOrigin        `json:"origin"`
	Gamification *GamificationProfile `json:"gamification"`
	Preferences  *UserPreferences     `json:"preferences"`
}

type UserPreferences struct {
	DietaryRestrictions []string `json:"dietaryRestrictions,omitempty"`
	DefaultPortions     *int32   `json:"defaultPortions,omitempty"`
	Currency            Currency `json:"currency"`
}

type UserPreferencesInput struct {
	DietaryRestrictions []string  `json:"dietaryRestrictions,omitempty"`
	DefaultPortions     *int32    `json:"defaultPortions,omitempty"`
	Currency            *Currency `json:"currency,omitempty"`
}

type AccountOrigin string

const (
	AccountOriginMicrosoft AccountOrigin = "MICROSOFT"
	AccountOriginGoogle    AccountOrigin = "GOOGLE"
	AccountOriginApple     AccountOrigin = "APPLE"
)

var AllAccountOrigin = []AccountOrigin{
	AccountOriginMicrosoft,
	AccountOriginGoogle,
	AccountOriginApple,
}

func (e AccountOrigin) IsValid() bool {
	switch e {
	case AccountOriginMicrosoft, AccountOriginGoogle, AccountOriginApple:
		return true
	}
	return false
}

func (e AccountOrigin) String() string {
	return string(e)
}

func (e *AccountOrigin) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccountOrigin(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccountOrigin", str)
	}
	return nil
}

func (e AccountOrigin) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AccountOrigin) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AccountOrigin) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type Currency string

const (
	CurrencyUsd Currency = "USD"
	CurrencyEur Currency = "EUR"
)

var AllCurrency = []Currency{
	CurrencyUsd,
	CurrencyEur,
}

func (e Currency) IsValid() bool {
	switch e {
	case CurrencyUsd, CurrencyEur:
		return true
	}
	return false
}

func (e Currency) String() string {
	return string(e)
}

func (e *Currency) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Currency(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Currency", str)
	}
	return nil
}

func (e Currency) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Currency) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Currency) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ExpiryType string

const (
	ExpiryTypeExpiration ExpiryType = "EXPIRATION"
	ExpiryTypeBestBefore ExpiryType = "BEST_BEFORE"
)

var AllExpiryType = []ExpiryType{
	ExpiryTypeExpiration,
	ExpiryTypeBestBefore,
}

func (e ExpiryType) IsValid() bool {
	switch e {
	case ExpiryTypeExpiration, ExpiryTypeBestBefore:
		return true
	}
	return false
}

func (e ExpiryType) String() string {
	return string(e)
}

func (e *ExpiryType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExpiryType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExpiryType", str)
	}
	return nil
}

func (e ExpiryType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ExpiryType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ExpiryType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ItemStatus string

const (
	ItemStatusAvailable ItemStatus = "AVAILABLE"
	ItemStatusConsumed  ItemStatus = "CONSUMED"
	ItemStatusWasted    ItemStatus = "WASTED"
	ItemStatusInStaging ItemStatus = "IN_STAGING"
)

var AllItemStatus = []ItemStatus{
	ItemStatusAvailable,
	ItemStatusConsumed,
	ItemStatusWasted,
	ItemStatusInStaging,
}

func (e ItemStatus) IsValid() bool {
	switch e {
	case ItemStatusAvailable, ItemStatusConsumed, ItemStatusWasted, ItemStatusInStaging:
		return true
	}
	return false
}

func (e ItemStatus) String() string {
	return string(e)
}

func (e *ItemStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ItemStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ItemStatus", str)
	}
	return nil
}

func (e ItemStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ItemStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ItemStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type RecipeStatus string

const (
	RecipeStatusProposed      RecipeStatus = "PROPOSED"
	RecipeStatusSaved         RecipeStatus = "SAVED"
	RecipeStatusInPreparation RecipeStatus = "IN_PREPARATION"
	RecipeStatusCooked        RecipeStatus = "COOKED"
)

var AllRecipeStatus = []RecipeStatus{
	RecipeStatusProposed,
	RecipeStatusSaved,
	RecipeStatusInPreparation,
	RecipeStatusCooked,
}

func (e RecipeStatus) IsValid() bool {
	switch e {
	case RecipeStatusProposed, RecipeStatusSaved, RecipeStatusInPreparation, RecipeStatusCooked:
		return true
	}
	return false
}

func (e RecipeStatus) String() string {
	return string(e)
}

func (e *RecipeStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RecipeStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RecipeStatus", str)
	}
	return nil
}

func (e RecipeStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RecipeStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RecipeStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type Unit string

const (
	UnitG  Unit = "G"
	UnitKg Unit = "KG"
	UnitMl Unit = "ML"
	UnitL  Unit = "L"
	UnitPz Unit = "PZ"
	UnitQb Unit = "QB"
)

var AllUnit = []Unit{
	UnitG,
	UnitKg,
	UnitMl,
	UnitL,
	UnitPz,
	UnitQb,
}

func (e Unit) IsValid() bool {
	switch e {
	case UnitG, UnitKg, UnitMl, UnitL, UnitPz, UnitQb:
		return true
	}
	return false
}

func (e Unit) String() string {
	return string(e)
}

func (e *Unit) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Unit(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Unit", str)
	}
	return nil
}

func (e Unit) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Unit) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Unit) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
